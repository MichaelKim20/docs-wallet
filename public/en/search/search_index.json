{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"01-what-is-a-blockchain/","text":"What is a Blockchain? Ever since the beginning, people have been trying to figure out how to get rid of the middleman. Every time you log in somewhere on the internet, whether it\u2019s Facebook or your bank, that\u2019s a middleman. And the middleman owns and controls the database you log into. On the internet, up until recently, there was nothing but middlemen. It would be nice if we could get rid of the middleman. Just let everyone have their own copy of the database so they could interact with each other without a middleman. There are two big challenges with this. First, you have to make sure everyone\u2019s copy of the database is the same, and second, you have to make sure nobody messes with it. In other words, you have to trust everyone. And in a network where you don\u2019t know everyone, that can be hard to do. Blockchain is a way to get rid of the middleman. It does that by distributing the database (or ledger) to everyone who wants to participate in the blockchain network. That\u2019s why blockchain is also referred to as a distributed ledger . More importantly, the blockchain also makes sure everyone\u2019s copy of the database is the same and that nobody changes anything. How does the blockchain do that? Two ways. First, periodic entries (called blocks ) are made in the blockchain ledger that everyone agrees is accurate before they make the entry. The blockchain uses complex mathematics, called a consensus algorithm , to ensure agreement. Once the agreed-upon entry is made, the blockchain then ensures that it is impossible to change the entry. This idea of making something impossible to change once it is written is called immutability and it\u2019s the key to the power of blockchain. The blockchain ensures immutability by linking each of the blocks in the ledger together in chronological order. They are linked in such a way that a change to anyone block would change every block from that one forward and that one change would be immediately apparent to everyone in the network who would know something has changed. The participants in the network would get together and reject that change. What do these blocks contain? They can contain any data, but mostly what they contain are transactions in chronological order. Transactions like deposits and withdrawals into an account or transfer of ownership of some asset. The kinds of transactions you definitely want to be immutable because the details of these transactions are permanently imprinted into the blockchain.","title":"What is a Blockchain?"},{"location":"01-what-is-a-blockchain/#what-is-a-blockchain","text":"Ever since the beginning, people have been trying to figure out how to get rid of the middleman. Every time you log in somewhere on the internet, whether it\u2019s Facebook or your bank, that\u2019s a middleman. And the middleman owns and controls the database you log into. On the internet, up until recently, there was nothing but middlemen. It would be nice if we could get rid of the middleman. Just let everyone have their own copy of the database so they could interact with each other without a middleman. There are two big challenges with this. First, you have to make sure everyone\u2019s copy of the database is the same, and second, you have to make sure nobody messes with it. In other words, you have to trust everyone. And in a network where you don\u2019t know everyone, that can be hard to do. Blockchain is a way to get rid of the middleman. It does that by distributing the database (or ledger) to everyone who wants to participate in the blockchain network. That\u2019s why blockchain is also referred to as a distributed ledger . More importantly, the blockchain also makes sure everyone\u2019s copy of the database is the same and that nobody changes anything. How does the blockchain do that? Two ways. First, periodic entries (called blocks ) are made in the blockchain ledger that everyone agrees is accurate before they make the entry. The blockchain uses complex mathematics, called a consensus algorithm , to ensure agreement. Once the agreed-upon entry is made, the blockchain then ensures that it is impossible to change the entry. This idea of making something impossible to change once it is written is called immutability and it\u2019s the key to the power of blockchain. The blockchain ensures immutability by linking each of the blocks in the ledger together in chronological order. They are linked in such a way that a change to anyone block would change every block from that one forward and that one change would be immediately apparent to everyone in the network who would know something has changed. The participants in the network would get together and reject that change. What do these blocks contain? They can contain any data, but mostly what they contain are transactions in chronological order. Transactions like deposits and withdrawals into an account or transfer of ownership of some asset. The kinds of transactions you definitely want to be immutable because the details of these transactions are permanently imprinted into the blockchain.","title":"What is a Blockchain?"},{"location":"02-what-is-a-cryptocurrency/","text":"What is a Cryptocurrency? The original definition of cryptocurrency was that of digital or virtual money secured by cryptography. There is no physical version of cryptocurrency (like bills or coins). This definition could easily include cryptocurrency issued by your bank or the government. Today, cryptocurrency has come to mean digital or virtual money, secured by cryptography AND stored on a blockchain. Cryptocurrency is now understood to be decentralized cryptocurrency\u2014cryptocurrency stored on a decentralized ledger. Decentralized cryptocurrency comes with one really big challenge called the double spend problem . Since cryptocurrency is nothing more than a copy of a digital file on a ledger, and everyone with a ledger has a copy of the same file, what keeps multiple people from spending the same tender multiple times? Nothing. This is a problem that comes down to who owns what. That\u2019s where blockchain comes in because it solves the double spend problem with cryptocurrency. Recall that the blockchain ensures agreement among all parties prior to a transaction and once the transaction is confirmed, it can never be changed. If you send or receive cryptocurrency via a blockchain, everyone in the network will agree to the nature of the transaction before it is inscribed permanently onto the blockchain ledger. Cryptocurrency is generally created in one of two ways: mined or minted. Mining cryptocurrency involves members of the blockchain network performing some action or activity for which they are rewarded a specific amount of cryptocurrency according to a pre-defined and agreed-upon formula or algorithm. Minting cryptocurrency also happens according to a pre-defined and agreed-upon formula or algorithm. But in this case, the algorithm is established by the creators of the specific blockchain and the cryptocurrency comes into existence according to the algorithm without any members of the blockchain network doing anything.","title":"What is a Cryptocurrency?"},{"location":"02-what-is-a-cryptocurrency/#what-is-a-cryptocurrency","text":"The original definition of cryptocurrency was that of digital or virtual money secured by cryptography. There is no physical version of cryptocurrency (like bills or coins). This definition could easily include cryptocurrency issued by your bank or the government. Today, cryptocurrency has come to mean digital or virtual money, secured by cryptography AND stored on a blockchain. Cryptocurrency is now understood to be decentralized cryptocurrency\u2014cryptocurrency stored on a decentralized ledger. Decentralized cryptocurrency comes with one really big challenge called the double spend problem . Since cryptocurrency is nothing more than a copy of a digital file on a ledger, and everyone with a ledger has a copy of the same file, what keeps multiple people from spending the same tender multiple times? Nothing. This is a problem that comes down to who owns what. That\u2019s where blockchain comes in because it solves the double spend problem with cryptocurrency. Recall that the blockchain ensures agreement among all parties prior to a transaction and once the transaction is confirmed, it can never be changed. If you send or receive cryptocurrency via a blockchain, everyone in the network will agree to the nature of the transaction before it is inscribed permanently onto the blockchain ledger. Cryptocurrency is generally created in one of two ways: mined or minted. Mining cryptocurrency involves members of the blockchain network performing some action or activity for which they are rewarded a specific amount of cryptocurrency according to a pre-defined and agreed-upon formula or algorithm. Minting cryptocurrency also happens according to a pre-defined and agreed-upon formula or algorithm. But in this case, the algorithm is established by the creators of the specific blockchain and the cryptocurrency comes into existence according to the algorithm without any members of the blockchain network doing anything.","title":"What is a Cryptocurrency?"},{"location":"03-why-the-need-for-bosagora/","text":"Why The Need For Bosagora? Few technologies are invented and perfected at the same time. Such was the case for the first blockchain, which is the central technology behind Bitcoin\u2014the first decentralized cryptocurrency. The first blockchain was very good at doing the two things it was asked to do: consensus and immutability. Beyond that, it is pretty limited. Once people saw the potential of blockchain to enforce consensus and immutability, they wanted to decentralize other things, like business contracts (called smart contracts ). Unfortunately, the first blockchain had no capability to do anything other than mine and manage Bitcoin. It was clear that for blockchain to gain wider acceptance, it would need increased functionality. For blockchain to become even more useful going forward, it needs to evolve beyond the limited capability of early blockchains. There is a fundamental challenge to the evolution of blockchain, however. How to add the freedom and flexibility to do more things while still maintaining consensus and immutability in a decentralized network? This is the challenge that Bosagora has undertaken.","title":"Why The Need For Bosagora?"},{"location":"03-why-the-need-for-bosagora/#why-the-need-for-bosagora","text":"Few technologies are invented and perfected at the same time. Such was the case for the first blockchain, which is the central technology behind Bitcoin\u2014the first decentralized cryptocurrency. The first blockchain was very good at doing the two things it was asked to do: consensus and immutability. Beyond that, it is pretty limited. Once people saw the potential of blockchain to enforce consensus and immutability, they wanted to decentralize other things, like business contracts (called smart contracts ). Unfortunately, the first blockchain had no capability to do anything other than mine and manage Bitcoin. It was clear that for blockchain to gain wider acceptance, it would need increased functionality. For blockchain to become even more useful going forward, it needs to evolve beyond the limited capability of early blockchains. There is a fundamental challenge to the evolution of blockchain, however. How to add the freedom and flexibility to do more things while still maintaining consensus and immutability in a decentralized network? This is the challenge that Bosagora has undertaken.","title":"Why The Need For Bosagora?"},{"location":"04-bosagora-platform-overview/","text":"Bosagora Platform Overview The Bosagora Foundation was founded to make blockchain technology more of a project enabler. To do that, blockchain must be true to its roots of ensuring consensus and immutability in a decentralized network. But to evolve, it must also enable scalability, efficiency and increased functionality, while simultaneously ensuring transparency, legitimacy, and fairness. This is what Bosagora does. The Bosagora platform includes its own cryptocurrency (called BOA ), its own blockchain protocol, a smart contract engine, and an easy-to-use programming language with development tools. The platform enables the creation of Trust Contracts and includes an embedded decision-making system called The Congress Network . The guiding principle behind Bosagora is free and inclusive decision-making with deliberative, democratic decision-making about changes to the blockchain. All of these combine to create a blockchain ecosystem that ensures transparency of the consensus algorithm and the clarity of contracts.","title":"Bosagora Platform Overview"},{"location":"04-bosagora-platform-overview/#bosagora-platform-overview","text":"The Bosagora Foundation was founded to make blockchain technology more of a project enabler. To do that, blockchain must be true to its roots of ensuring consensus and immutability in a decentralized network. But to evolve, it must also enable scalability, efficiency and increased functionality, while simultaneously ensuring transparency, legitimacy, and fairness. This is what Bosagora does. The Bosagora platform includes its own cryptocurrency (called BOA ), its own blockchain protocol, a smart contract engine, and an easy-to-use programming language with development tools. The platform enables the creation of Trust Contracts and includes an embedded decision-making system called The Congress Network . The guiding principle behind Bosagora is free and inclusive decision-making with deliberative, democratic decision-making about changes to the blockchain. All of these combine to create a blockchain ecosystem that ensures transparency of the consensus algorithm and the clarity of contracts.","title":"Bosagora Platform Overview"},{"location":"05-trust-contracts/","text":"Trust Contracts To add smart contract functionality to the blockchain requires a couple of things. First, you\u2019ll need some kind of programming language to create the kind of complex math and algorithms necessary to implement business rules on the blockchain. The first attempts to add smart contracts to the blockchain, like Ethereum, included a Turing-complete programming language to write smart contracts. A Turing-complete system can be proven mathematically to be capable of performing any possible calculation or computer program. However, it is possible that a Turing-complete language might be inappropriate for writing a smart contract as they are inherently undecidable . Due to this undecidability issue, a smart contract based on a Turing-complete language will make it difficult to know what a smart contract will do before running it. The second thing you\u2019ll need is some way to execute those programs faster than is possible in the native blockchain environment. Blockchains were designed for consensus and immutability, not computation. To address both of these challenges, Bosagora has developed the idea of the Trust Contract . Trust Contracts provide a decidable and approachable framework for creating and executing smart contracts on the blockchain. Trust Contracts enable the programming of decidable contracts, either by using a flexible programming language on a virtual machine or using a slightly less flexible, but decidable, domain-specific language. To overcome performance limitations inherent in blockchain, Trust Contracts utilize WebAssembly . WebAssembly provides a way to run code, written in multiple languages, on the web at near-native speed, with client apps running on the web that previously couldn\u2019t have done so. The ultimate goal of this architecture is to enable users to build a decidable contract, which ensures safe and accurate execution while maximizing its scalability.","title":"Trust Contracts"},{"location":"05-trust-contracts/#trust-contracts","text":"To add smart contract functionality to the blockchain requires a couple of things. First, you\u2019ll need some kind of programming language to create the kind of complex math and algorithms necessary to implement business rules on the blockchain. The first attempts to add smart contracts to the blockchain, like Ethereum, included a Turing-complete programming language to write smart contracts. A Turing-complete system can be proven mathematically to be capable of performing any possible calculation or computer program. However, it is possible that a Turing-complete language might be inappropriate for writing a smart contract as they are inherently undecidable . Due to this undecidability issue, a smart contract based on a Turing-complete language will make it difficult to know what a smart contract will do before running it. The second thing you\u2019ll need is some way to execute those programs faster than is possible in the native blockchain environment. Blockchains were designed for consensus and immutability, not computation. To address both of these challenges, Bosagora has developed the idea of the Trust Contract . Trust Contracts provide a decidable and approachable framework for creating and executing smart contracts on the blockchain. Trust Contracts enable the programming of decidable contracts, either by using a flexible programming language on a virtual machine or using a slightly less flexible, but decidable, domain-specific language. To overcome performance limitations inherent in blockchain, Trust Contracts utilize WebAssembly . WebAssembly provides a way to run code, written in multiple languages, on the web at near-native speed, with client apps running on the web that previously couldn\u2019t have done so. The ultimate goal of this architecture is to enable users to build a decidable contract, which ensures safe and accurate execution while maximizing its scalability.","title":"Trust Contracts"},{"location":"06-proof-of-stake/","text":"Proof of Stake? One of the chief components of any blockchain is the consensus algorithm. The consensus algorithm is the method by which all the nodes in the blockchain come to an agreement on what is in a block before it gets permanently stored there. Consensus algorithms try and balance two requirements: they should be robust and efficient. In other words, you want the algorithm to ensure consensus using the least amount of resources. There are three main protocols used in consensus algorithms for blockchains today. The first protocol used\u2014the one used for Bitcoin\u2014is Proof of Work (PoW). It operates by having every node do a mathematically difficult computation. It\u2019s a very safe (i.e., robust) algorithm, but very inefficient as it requires a considerable amount of computation power (from each node) and therefore requires a lot of electrical power. The next generation of protocols is Proof of Stake (PoS). Here each node stakes some cryptocurrency (called tokens ) for the right to vote on a transaction. Unlike PoW, PoS is not computationally intensive. It is, however, not as robust as PoW. The third protocol is Delegated Proof of Stake (DPoS). Like PoS, each node stakes some tokens for the right to vote. But in this case, the nodes don't vote on transactions. Instead, they vote for delegates and the delegates vote on the transactions. Delegates are a subset of trusted nodes that are elected by the other nodes. Since only a subset of nodes has to validate transactions, consensus can be reached faster with DPoS. Fewer nodes voting however is also less robust. Requiring unanimous agreement by all participating nodes (like PoW and PoS) is referred to as a Byzantine agreement . DPoS on the other hand, which does not require unanimous agreement by all nodes to reach consensus, is called a Federated Byzantine agreement (FBA). Since they don\u2019t have to wait for a unanimous vote, FBA protocols result in faster blockchain transactions. Bosagora uses a modified version of the Federated Byzantine Agreement and (mFBA) consensus algorithm. In addition to FBA, the Bosagora consensus protocol also applies a PoS feature for the maintenance of a governance system. Transaction validators are required to freeze 40,000 BOA within a node and keep them there. The frozen coins in the node then act as both an economic incentive (in the form of confirmation rewards) to operate a node and collateral for the security and integrity of the information held in the node and blockchain.","title":"Proof of Stake"},{"location":"06-proof-of-stake/#proof-of-stake","text":"One of the chief components of any blockchain is the consensus algorithm. The consensus algorithm is the method by which all the nodes in the blockchain come to an agreement on what is in a block before it gets permanently stored there. Consensus algorithms try and balance two requirements: they should be robust and efficient. In other words, you want the algorithm to ensure consensus using the least amount of resources. There are three main protocols used in consensus algorithms for blockchains today. The first protocol used\u2014the one used for Bitcoin\u2014is Proof of Work (PoW). It operates by having every node do a mathematically difficult computation. It\u2019s a very safe (i.e., robust) algorithm, but very inefficient as it requires a considerable amount of computation power (from each node) and therefore requires a lot of electrical power. The next generation of protocols is Proof of Stake (PoS). Here each node stakes some cryptocurrency (called tokens ) for the right to vote on a transaction. Unlike PoW, PoS is not computationally intensive. It is, however, not as robust as PoW. The third protocol is Delegated Proof of Stake (DPoS). Like PoS, each node stakes some tokens for the right to vote. But in this case, the nodes don't vote on transactions. Instead, they vote for delegates and the delegates vote on the transactions. Delegates are a subset of trusted nodes that are elected by the other nodes. Since only a subset of nodes has to validate transactions, consensus can be reached faster with DPoS. Fewer nodes voting however is also less robust. Requiring unanimous agreement by all participating nodes (like PoW and PoS) is referred to as a Byzantine agreement . DPoS on the other hand, which does not require unanimous agreement by all nodes to reach consensus, is called a Federated Byzantine agreement (FBA). Since they don\u2019t have to wait for a unanimous vote, FBA protocols result in faster blockchain transactions. Bosagora uses a modified version of the Federated Byzantine Agreement and (mFBA) consensus algorithm. In addition to FBA, the Bosagora consensus protocol also applies a PoS feature for the maintenance of a governance system. Transaction validators are required to freeze 40,000 BOA within a node and keep them there. The frozen coins in the node then act as both an economic incentive (in the form of confirmation rewards) to operate a node and collateral for the security and integrity of the information held in the node and blockchain.","title":"Proof of Stake?"},{"location":"07-bosagora-nodes/","text":"Bosagora Nodes Agora In Bosagora, the nodes comprise the blockchain which is called Agora . In early blockchains, like Bitcoin, the nodes are responsible for enforcing the consensus algorithm and storing the blocks and not much more. The nodes in Agora have other responsibilities and opportunities. Nodes and Validators Anyone can run a full node in Agora. You do not need to make an investment in BOA to run a full node. Perhaps you just want to support the network. Or maybe you\u2019ll want to participate more later on. There are no technical specs released yet for running a full node, but they will be announced around the time we\u2019re ready to launch. If you want to participate in Agora more than just running a full node, there are two ways to do that. The first is as a validator . You must run a full node in order to be a validator. Validators have the opportunity to partake in confirming blocks and validating Agora transactions. Validators have financial incentives to do so in the form of BOA rewards. There are two ways for validators to receive BOA rewards: confirmation rewards and transaction fees. Confirmation rewards are given to a validator when they contribute to a block confirmation. Transaction fees are applied to all transactions and consist of a fixed transaction fee (i.e., it\u2019s the same amount for all transactions) and a data fee which is proportional to the size of the transaction data (i.e., larger data transactions cost more). To run a full node and receive an incentive as a validator, you must freeze some BOA. The frozen BOA function as a security deposit against an attempt to forge the blockchain. In other words, if a node tries to forge the blockchain, some of the frozen BOA will be confiscated and sent to the Commons Budget account. Anyone who fulfills the following conditions can become a validator: Freeze at least 40,000 BOA and forgo liquidity Operate a full node at a stable network speed (operate in a server or personal computer) The second way to participate in Agora is as a member of The Congress Network . Validators in Agora can join The Congress Network. The Congress Network, which follows the rule of one node-one vote, is a way for the nodes in the network to participate in democratic decision-making with regard to the evolution of the network. Members of The Congress Network also get to participate in the decision-making of how to provision the Commons Budgets . The Common Budget is a fund of BOA cryptocurrency which is used for system upgrades and any other proposal which benefits the entire Bosagora ecosystem. The members of The Congress Network can set nodes in two directions depending on their goals: Operating a greater number of nodes increases their voting power Accumulating BOA in a single node reduces node operating costs Enrollment Process Participants are called validators, while observers of the consensus protocol are called nodes. While every validator is a node, not every node is a validator. In order for a node to become a validator, and begin a validation cycle, it must complete the enrollment process . Once that node completes the enrollment process, it immediately becomes a validator, collecting and propagating transactions. When a node originally enrolls, it is not yet assigned a quorum set and is therefore expected to be passive (sign blocks only when they reach the 50% threshold) until the next quorum balancing event happens.","title":"Bosagora Nodes"},{"location":"07-bosagora-nodes/#bosagora-nodes","text":"","title":"Bosagora Nodes"},{"location":"07-bosagora-nodes/#agora","text":"In Bosagora, the nodes comprise the blockchain which is called Agora . In early blockchains, like Bitcoin, the nodes are responsible for enforcing the consensus algorithm and storing the blocks and not much more. The nodes in Agora have other responsibilities and opportunities.","title":"Agora"},{"location":"07-bosagora-nodes/#nodes-and-validators","text":"Anyone can run a full node in Agora. You do not need to make an investment in BOA to run a full node. Perhaps you just want to support the network. Or maybe you\u2019ll want to participate more later on. There are no technical specs released yet for running a full node, but they will be announced around the time we\u2019re ready to launch. If you want to participate in Agora more than just running a full node, there are two ways to do that. The first is as a validator . You must run a full node in order to be a validator. Validators have the opportunity to partake in confirming blocks and validating Agora transactions. Validators have financial incentives to do so in the form of BOA rewards. There are two ways for validators to receive BOA rewards: confirmation rewards and transaction fees. Confirmation rewards are given to a validator when they contribute to a block confirmation. Transaction fees are applied to all transactions and consist of a fixed transaction fee (i.e., it\u2019s the same amount for all transactions) and a data fee which is proportional to the size of the transaction data (i.e., larger data transactions cost more). To run a full node and receive an incentive as a validator, you must freeze some BOA. The frozen BOA function as a security deposit against an attempt to forge the blockchain. In other words, if a node tries to forge the blockchain, some of the frozen BOA will be confiscated and sent to the Commons Budget account. Anyone who fulfills the following conditions can become a validator: Freeze at least 40,000 BOA and forgo liquidity Operate a full node at a stable network speed (operate in a server or personal computer) The second way to participate in Agora is as a member of The Congress Network . Validators in Agora can join The Congress Network. The Congress Network, which follows the rule of one node-one vote, is a way for the nodes in the network to participate in democratic decision-making with regard to the evolution of the network. Members of The Congress Network also get to participate in the decision-making of how to provision the Commons Budgets . The Common Budget is a fund of BOA cryptocurrency which is used for system upgrades and any other proposal which benefits the entire Bosagora ecosystem. The members of The Congress Network can set nodes in two directions depending on their goals: Operating a greater number of nodes increases their voting power Accumulating BOA in a single node reduces node operating costs","title":"Nodes and Validators"},{"location":"07-bosagora-nodes/#enrollment-process","text":"Participants are called validators, while observers of the consensus protocol are called nodes. While every validator is a node, not every node is a validator. In order for a node to become a validator, and begin a validation cycle, it must complete the enrollment process . Once that node completes the enrollment process, it immediately becomes a validator, collecting and propagating transactions. When a node originally enrolls, it is not yet assigned a quorum set and is therefore expected to be passive (sign blocks only when they reach the 50% threshold) until the next quorum balancing event happens.","title":"Enrollment Process"},{"location":"08-how-to-purchase-boa/","text":"How to Purchase BOA Note : We are not offering investment advice. Please conduct your own research and due diligence, or consult a financial professional before making any investment decisions. Like any other cryptocurrency, BOA can be purchased using one of the exchanges. We do not recommend any particular exchange, as there are many great options. You can see the list of available exchanges and the current price of BOA at CoinMarketCap . Step 1 Download a wallet Download and install a cryptocurrency wallet that supports BOA. Create a new wallet and name it. Activate your new wallet and be sure to write down your new passwords. Your passwords are the only way you can access your wallet so keep them in a safe place and don\u2019t lose them. You will have two passwords: one for spending (which is the one used for transacting on an exchange) and a 12- or 24-word passphrase (which depends on the wallet you chose). Recreate your passphrase and accept the terms and conditions. The wallet should now be all set. Click Receive and copy the wallet address or download a PDF file with the QR code. You will need to use this address to receive your cryptocurrency later. Step 2 Choose an exchange Explore cryptocurrency exchanges and choose one that supports BOA. Create an account. To create an account, exchanges typically require the following information: Full name Address Email address and phone number Payment method (to fund your account) A document that identifies your personality (passport, driver\u2019s license, ID, etc) We recommend setting up two-factor authentication (2FA) for enhanced security. It usually takes from several minutes to several days for an account to be activated which depends on the exchange you choose. Step 3 Purchase BOA Sign in to your exchange account. Select a Buy/Sell option, which is usually on the top menu. Click Buy and enter BOA (Bosagora) as the cryptocurrency you wish to purchase. Indicate the amount of BOA you would like to purchase and select a payment method (whether it is a wire transfer, credit, or debit card). Each exchange will offer you available options. Please read them carefully and follow the outlined steps. Confirm your purchase. You will typically have to confirm it via email and enter the 2FA code (if you set it up). You will then receive your BOA on the exchange account. Withdraw BOA to your personal wallet. If this is the first time you are making a withdrawal, try a small amount to verify that everything works. It is not recommended to store BOA (or any other cryptocurrency) in your exchange account. To transfer your BOA, choose the Withdraw option, paste your wallet address (the one you copied earlier from your wallet) and submit your transfer. Check to see if you have received your funds by going to your wallet and checking the balance. You can also track recent transactions using different explorer tools. You can now store BOA in your personal wallet, transact between different addresses and receive more BOA as rewards.","title":"How to Purchase BOA"},{"location":"08-how-to-purchase-boa/#how-to-purchase-boa","text":"Note : We are not offering investment advice. Please conduct your own research and due diligence, or consult a financial professional before making any investment decisions. Like any other cryptocurrency, BOA can be purchased using one of the exchanges. We do not recommend any particular exchange, as there are many great options. You can see the list of available exchanges and the current price of BOA at CoinMarketCap . Step 1 Download a wallet Download and install a cryptocurrency wallet that supports BOA. Create a new wallet and name it. Activate your new wallet and be sure to write down your new passwords. Your passwords are the only way you can access your wallet so keep them in a safe place and don\u2019t lose them. You will have two passwords: one for spending (which is the one used for transacting on an exchange) and a 12- or 24-word passphrase (which depends on the wallet you chose). Recreate your passphrase and accept the terms and conditions. The wallet should now be all set. Click Receive and copy the wallet address or download a PDF file with the QR code. You will need to use this address to receive your cryptocurrency later. Step 2 Choose an exchange Explore cryptocurrency exchanges and choose one that supports BOA. Create an account. To create an account, exchanges typically require the following information: Full name Address Email address and phone number Payment method (to fund your account) A document that identifies your personality (passport, driver\u2019s license, ID, etc) We recommend setting up two-factor authentication (2FA) for enhanced security. It usually takes from several minutes to several days for an account to be activated which depends on the exchange you choose. Step 3 Purchase BOA Sign in to your exchange account. Select a Buy/Sell option, which is usually on the top menu. Click Buy and enter BOA (Bosagora) as the cryptocurrency you wish to purchase. Indicate the amount of BOA you would like to purchase and select a payment method (whether it is a wire transfer, credit, or debit card). Each exchange will offer you available options. Please read them carefully and follow the outlined steps. Confirm your purchase. You will typically have to confirm it via email and enter the 2FA code (if you set it up). You will then receive your BOA on the exchange account. Withdraw BOA to your personal wallet. If this is the first time you are making a withdrawal, try a small amount to verify that everything works. It is not recommended to store BOA (or any other cryptocurrency) in your exchange account. To transfer your BOA, choose the Withdraw option, paste your wallet address (the one you copied earlier from your wallet) and submit your transfer. Check to see if you have received your funds by going to your wallet and checking the balance. You can also track recent transactions using different explorer tools. You can now store BOA in your personal wallet, transact between different addresses and receive more BOA as rewards.","title":"How to Purchase BOA"},{"location":"09-consensus-algorithm/","text":"Consensus Algorithm The consensus algorithm is central to any blockchain-based currency or system. The consensus algorithm attempts to answer the question, \u201cHow can we prove with confidence that all distributed databases hold the same set of information?\u201d As blockchains have evolved, so too have the consensus algorithms. The first generation was based on a Byzantine Agreement (BA). BA requires that all the nodes in the blockchain form a consensus. Requiring unanimous agreement can be challenging as the number of blockchain nodes grows. FBA The next generation of consensus algorithms are based on Federated Byzantine Agreement (FBA). Rather than have every node in the blockchain vote on consensus, a network consisting of quorums votes on consensus, where each quorum is a set of nodes sufficient to reach an agreement. The consensus process is achieved via the quorums, and the collective agreement of the quorums is used as the final decision of the entire network. FBA powers the Stellar Network , the 8th largest cryptocurrency with a market capitalization of over $2.5 billion. There are two main features that make FBA suitable for the Bosagora consensus protocol. First, because it doesn\u2019t have to wait to hear from every node, confirmation of the transaction is fast (transactions confirm every 3 \u2013 5 seconds). As a utility coin, confirmation speed and low latency are critical to be utilized in a real-life environment. Second, because validators are not chosen by someone or some organization, membership in the blockchain is completely open to the public. This is in contrast to the Stellar Network, where everyone who wants to join the network needs permission from someone. mFBA For Bosagora, it is not only important for anyone to be able to join the network, but also for them to be able to participate in validation without authorization. The way we do that is by combining Proof of Stake (PoS) with FBA, which we refer to as modified FBA (mFBA). In this case, we use PoS for the maintenance of the governance system. Anybody can be a validator, as long as they stake 40,000 BOA cryptocurrency within a node and forgo liquidity (i.e., they can\u2019t sell that BOA). The frozen BOA in the node acts as both an economic incentive (via confirmation rewards) to operate a node, as well as collateral for the security and integrity of the information held in the node\u2019s blockchain. According to the pre-set rules, if a node is discovered to have forged the blockchain on the node, the frozen BOA are forfeited to the Commons Budget.","title":"Consensus Algorithm"},{"location":"09-consensus-algorithm/#consensus-algorithm","text":"The consensus algorithm is central to any blockchain-based currency or system. The consensus algorithm attempts to answer the question, \u201cHow can we prove with confidence that all distributed databases hold the same set of information?\u201d As blockchains have evolved, so too have the consensus algorithms. The first generation was based on a Byzantine Agreement (BA). BA requires that all the nodes in the blockchain form a consensus. Requiring unanimous agreement can be challenging as the number of blockchain nodes grows.","title":"Consensus Algorithm"},{"location":"09-consensus-algorithm/#fba","text":"The next generation of consensus algorithms are based on Federated Byzantine Agreement (FBA). Rather than have every node in the blockchain vote on consensus, a network consisting of quorums votes on consensus, where each quorum is a set of nodes sufficient to reach an agreement. The consensus process is achieved via the quorums, and the collective agreement of the quorums is used as the final decision of the entire network. FBA powers the Stellar Network , the 8th largest cryptocurrency with a market capitalization of over $2.5 billion. There are two main features that make FBA suitable for the Bosagora consensus protocol. First, because it doesn\u2019t have to wait to hear from every node, confirmation of the transaction is fast (transactions confirm every 3 \u2013 5 seconds). As a utility coin, confirmation speed and low latency are critical to be utilized in a real-life environment. Second, because validators are not chosen by someone or some organization, membership in the blockchain is completely open to the public. This is in contrast to the Stellar Network, where everyone who wants to join the network needs permission from someone.","title":"FBA"},{"location":"09-consensus-algorithm/#mfba","text":"For Bosagora, it is not only important for anyone to be able to join the network, but also for them to be able to participate in validation without authorization. The way we do that is by combining Proof of Stake (PoS) with FBA, which we refer to as modified FBA (mFBA). In this case, we use PoS for the maintenance of the governance system. Anybody can be a validator, as long as they stake 40,000 BOA cryptocurrency within a node and forgo liquidity (i.e., they can\u2019t sell that BOA). The frozen BOA in the node acts as both an economic incentive (via confirmation rewards) to operate a node, as well as collateral for the security and integrity of the information held in the node\u2019s blockchain. According to the pre-set rules, if a node is discovered to have forged the blockchain on the node, the frozen BOA are forfeited to the Commons Budget.","title":"mFBA"},{"location":"10-dao/","text":"DAO A decentralized autonomous organization (DAO) is, in essence, computer code that is distributed on a blockchain. The computer code is written to automate organizational decisions and rules (including cryptocurrency transactions). The decisions and rules of the DAO are embedded in the code and execute automatically without human intervention. Both the rules and subsequent actions are recorded on the blockchain, which means everything is transparent and cannot be tampered with. In Bosagora, The Congress Network is a DAO. The Congress Network The Congress Network is the decision-making body for Bosagora comprised of fully synchronized node operators. The Congress Network was created to enable effective and inclusive collaboration among the various project stakeholders to continuously enhance the Bosagora software and ecosystem. For example, decisions on a system upgrade can be made through proposal, review, and voting within the Congress Network. All node operators of Bosagora can join The Congress Network. The Congress Network adheres to the 1-node-to-1-vote rule. There are two subjects about which The Congress makes decisions: system upgrade proposals and how to spend the Commons Budget. To ensure The Congress Network is inclusive and efficient, we will implement Votera , an online decision making tool. Votera has the following characteristics: Anonymity Flexibility Convenience Archiving Reporting Making Decisions in The Congress Network Making decisions in The Congress Network follows a 10-step procedure: Join The Congress Network Freeze at least 40,000 BOA Operate a full node Create an activity Start a discussion Vote on something Review something Enter a guide Link (optional) Name of activity Objective and description Deadline Advamced settings (optional) Commission fees (optional) Discuss Write opinions or leave comments Vote Recorded in the blockchain Inspect the vote The date and time each vote is saved No redundant votes Check the quorum for resolution Initially set as one-third of total members Pass the proposal Net % positive votes > net % negatives votes by > 10% Execute the proposal Do the work Allocate the Commons Budget according to the Trust Contract Review/Inspect Appropriate tasks have been completed Related expenses are compensated Rewards Members of The Congress Network can receive rewards (in BOA) for participating in the Congress. There are two ways for them to receive rewards: confirmation rewards and transaction fees . Confirmation Rewards : Are given to a node when a block is confirmed. This reward is crucial in providing a financial incentive to operate a node. The quantity issued to a node is proportional to the quantity of frozen BOA held in the node. The rewards are distributed to validators when a new block is created.","title":"DAO"},{"location":"10-dao/#dao","text":"A decentralized autonomous organization (DAO) is, in essence, computer code that is distributed on a blockchain. The computer code is written to automate organizational decisions and rules (including cryptocurrency transactions). The decisions and rules of the DAO are embedded in the code and execute automatically without human intervention. Both the rules and subsequent actions are recorded on the blockchain, which means everything is transparent and cannot be tampered with. In Bosagora, The Congress Network is a DAO.","title":"DAO"},{"location":"10-dao/#the-congress-network","text":"The Congress Network is the decision-making body for Bosagora comprised of fully synchronized node operators. The Congress Network was created to enable effective and inclusive collaboration among the various project stakeholders to continuously enhance the Bosagora software and ecosystem. For example, decisions on a system upgrade can be made through proposal, review, and voting within the Congress Network. All node operators of Bosagora can join The Congress Network. The Congress Network adheres to the 1-node-to-1-vote rule. There are two subjects about which The Congress makes decisions: system upgrade proposals and how to spend the Commons Budget. To ensure The Congress Network is inclusive and efficient, we will implement Votera , an online decision making tool. Votera has the following characteristics: Anonymity Flexibility Convenience Archiving Reporting","title":"The Congress Network"},{"location":"10-dao/#making-decisions-in-the-congress-network","text":"Making decisions in The Congress Network follows a 10-step procedure: Join The Congress Network Freeze at least 40,000 BOA Operate a full node Create an activity Start a discussion Vote on something Review something Enter a guide Link (optional) Name of activity Objective and description Deadline Advamced settings (optional) Commission fees (optional) Discuss Write opinions or leave comments Vote Recorded in the blockchain Inspect the vote The date and time each vote is saved No redundant votes Check the quorum for resolution Initially set as one-third of total members Pass the proposal Net % positive votes > net % negatives votes by > 10% Execute the proposal Do the work Allocate the Commons Budget according to the Trust Contract Review/Inspect Appropriate tasks have been completed Related expenses are compensated","title":"Making Decisions in The Congress Network"},{"location":"10-dao/#rewards","text":"Members of The Congress Network can receive rewards (in BOA) for participating in the Congress. There are two ways for them to receive rewards: confirmation rewards and transaction fees . Confirmation Rewards : Are given to a node when a block is confirmed. This reward is crucial in providing a financial incentive to operate a node. The quantity issued to a node is proportional to the quantity of frozen BOA held in the node. The rewards are distributed to validators when a new block is created.","title":"Rewards"},{"location":"11-utxo-configuration/","text":"UTXO Configuration The UTXO Model Receiving and spending BOA is similar to how it\u2019s done in Bitcoin in that all transactions involve UTXOs. UTXO, or unspent transaction output , is a fancy way of saying unspent coins or tokens. In other words, all transactions of BOA involve previously unspent BOA. Recall that one of the big challenges to decentralized cryptocurrency is the double spend problem. The UTXO model of cryptocurrency solves that problem by preventing double spending. How does it do that? UTXOs are used as the input to every BOA transaction and each of those UTXOs are uniquely identifiable by its transaction ID. During the transaction, all the input UTXOs are in effect destroyed. Should the transaction result in any outputs, new UTXOs, with new a transaction ID, are created. In this way, no UTXO can be spent twice because it is destroyed during spending. When a transaction is completed, any unspent outputs (i.e., UTXOs) are deposited back into a database which can then be used as inputs at a later date for a new transaction. Network nodes record and maintain a database that contains every UTXO available for spending. If someone tries to use a UTXO that isn\u2019t in that database, the nodes will reject it. The set of all existing UTXOs in the database at a given point in time is called the UTXO set . UTXO Tokens are Indivisible In most BOA transactions, new output UTXOs will be created because BOA UTXOs are indivisible. As an example, suppose you receive 30 BOA and then 40 BOA as confirmation rewards. You have 70 BOA total. Now, suppose you need to spend 35 BOA on a transaction fee. You can\u2019t just spend 35 BOA because all you have is a 30 BOA UTXO and a 40 BOA UTXO and they aren\u2019t divisible. It\u2019s like buying something for 50 cents when all you have is a dollar bill. You\u2019re going to have to spend the dollar and get change back. Because UTXOs are indivisible, in the above transaction, you\u2019ll have to spend the 40 BOA UTXO (i.e., the input) and receive a 5 BOA UTXO (i.e., the output) in return. As a result of the transaction, the input UTXO will be destroyed (removed from the database) and the new output UTXO will be created (added to the database).","title":"UTXO Configuration"},{"location":"11-utxo-configuration/#utxo-configuration","text":"","title":"UTXO Configuration"},{"location":"11-utxo-configuration/#the-utxo-model","text":"Receiving and spending BOA is similar to how it\u2019s done in Bitcoin in that all transactions involve UTXOs. UTXO, or unspent transaction output , is a fancy way of saying unspent coins or tokens. In other words, all transactions of BOA involve previously unspent BOA. Recall that one of the big challenges to decentralized cryptocurrency is the double spend problem. The UTXO model of cryptocurrency solves that problem by preventing double spending. How does it do that? UTXOs are used as the input to every BOA transaction and each of those UTXOs are uniquely identifiable by its transaction ID. During the transaction, all the input UTXOs are in effect destroyed. Should the transaction result in any outputs, new UTXOs, with new a transaction ID, are created. In this way, no UTXO can be spent twice because it is destroyed during spending. When a transaction is completed, any unspent outputs (i.e., UTXOs) are deposited back into a database which can then be used as inputs at a later date for a new transaction. Network nodes record and maintain a database that contains every UTXO available for spending. If someone tries to use a UTXO that isn\u2019t in that database, the nodes will reject it. The set of all existing UTXOs in the database at a given point in time is called the UTXO set .","title":"The UTXO Model"},{"location":"11-utxo-configuration/#utxo-tokens-are-indivisible","text":"In most BOA transactions, new output UTXOs will be created because BOA UTXOs are indivisible. As an example, suppose you receive 30 BOA and then 40 BOA as confirmation rewards. You have 70 BOA total. Now, suppose you need to spend 35 BOA on a transaction fee. You can\u2019t just spend 35 BOA because all you have is a 30 BOA UTXO and a 40 BOA UTXO and they aren\u2019t divisible. It\u2019s like buying something for 50 cents when all you have is a dollar bill. You\u2019re going to have to spend the dollar and get change back. Because UTXOs are indivisible, in the above transaction, you\u2019ll have to spend the 40 BOA UTXO (i.e., the input) and receive a 5 BOA UTXO (i.e., the output) in return. As a result of the transaction, the input UTXO will be destroyed (removed from the database) and the new output UTXO will be created (added to the database).","title":"UTXO Tokens are Indivisible"},{"location":"12-quorums/","text":"Quorums Overview Recall that FBA protocols implement a non-unanimous consensus mechanism by grouping nodes into groups known as quorums. In general, a quorum is the minimum number of people who must participate in a vote in order for a certain proposal to be executed. In the early stage of the Bosagora platform, a quorum for resolution was set to one-third of the total members. However, this can be adjusted later to reflect the average participation rate. Initially, quorums were based on Stellar\u2019s consensus protocol (SCP). But it has a weak point. The quorums on Stellar are configured manually by each node maintainer. This can lead to too much centralization if the quorums aren\u2019t configured properly. Bosagora addresses that shortcoming by using quorum balancing (see below). The rules for generating quorums on the Bosagora platform are as follows: Nodes with a bigger stake have a higher chance of being included in other nodes\u2019 quorums. The probability of inclusion is equal to the percentage of a node\u2019s stake compared to the stake of other nodes in the network. For example: If validators A, B, C stake 100K, 200K, 300K each, then validator C has a greater chance of being included in a node\u2019s quorum configuration compared to A and B. Randomness ensures that each node does not have the exact same quorum layout, as that would lead to too much centralization. At specified intervals, the quorums are shuffled. There are several checks to make sure quorums are generated correctly: There is a check that threshold values are correct. There is a quorum intersection check adapted from Stellar. It verifies there is sufficient quorum intersection in a given quorum configuration. There is a verification that network splits are not possible with the given quorum configuration. Quorum Slicing In an effort to incorporate trusted business relationships into the consensus process, FBA introduced the concept of a quorum slice . A quorum slice is a subset of nodes in a quorum that a given node chooses to trust and depend on. Validators get to decide which other validators they trust, and their list of trusted validators becomes their quorum slice. Every Bosagora validator node must be part of at least one quorum slice. An individual validator node can however appear in multiple quorum slices. Using quorum slices of trusted nodes not only produces quicker consensus but also ensures greater stability and reliability. Because these trusted nodes carry more weight in reaching consensus, even if a bad actor were to add a million malicious nodes to the network, it won\u2019t have any effect unless they can convince a critical mass of nodes to include them in their quorum slices. Quorum Balancing The problem with letting validators manually configure quorums is the opportunity for bias and centralization. This is the situation with SCP. The Bosagora team addressed this shortcoming by automating the quorum creation process which is referred to as quorum balancing . Quorum balancing helps everyone participate as a validator and is essential to realize a truly open membership. The idea is to make quorum configuration completely automated so there is no need for manual quorum configuration. Bosagora uses the set of all registered validators to automatically generate each node\u2019s quorum set. This ensures the quorum configuration is sufficiently decentralized. How does Bosagora ensure fairness in the configuration process? By using the pre-imaging technology from the consensus protocol to derive a randomness seed. This seed is then used as input to a deterministic pseudo-random number generator (PRNG). The PRNG then generates a specific sequence of numbers for a given seed (which ensures verifiability). This seed is then used to introduce randomness into the quorum. To further ensure fairness and randomness, the quorums are shuffled at specified intervals. This activity is referred to as quorum rebalancing . Currently, quorum rebalancing happens every hour.","title":"Quorums"},{"location":"12-quorums/#quorums","text":"","title":"Quorums"},{"location":"12-quorums/#overview","text":"Recall that FBA protocols implement a non-unanimous consensus mechanism by grouping nodes into groups known as quorums. In general, a quorum is the minimum number of people who must participate in a vote in order for a certain proposal to be executed. In the early stage of the Bosagora platform, a quorum for resolution was set to one-third of the total members. However, this can be adjusted later to reflect the average participation rate. Initially, quorums were based on Stellar\u2019s consensus protocol (SCP). But it has a weak point. The quorums on Stellar are configured manually by each node maintainer. This can lead to too much centralization if the quorums aren\u2019t configured properly. Bosagora addresses that shortcoming by using quorum balancing (see below). The rules for generating quorums on the Bosagora platform are as follows: Nodes with a bigger stake have a higher chance of being included in other nodes\u2019 quorums. The probability of inclusion is equal to the percentage of a node\u2019s stake compared to the stake of other nodes in the network. For example: If validators A, B, C stake 100K, 200K, 300K each, then validator C has a greater chance of being included in a node\u2019s quorum configuration compared to A and B. Randomness ensures that each node does not have the exact same quorum layout, as that would lead to too much centralization. At specified intervals, the quorums are shuffled. There are several checks to make sure quorums are generated correctly: There is a check that threshold values are correct. There is a quorum intersection check adapted from Stellar. It verifies there is sufficient quorum intersection in a given quorum configuration. There is a verification that network splits are not possible with the given quorum configuration.","title":"Overview"},{"location":"12-quorums/#quorum-slicing","text":"In an effort to incorporate trusted business relationships into the consensus process, FBA introduced the concept of a quorum slice . A quorum slice is a subset of nodes in a quorum that a given node chooses to trust and depend on. Validators get to decide which other validators they trust, and their list of trusted validators becomes their quorum slice. Every Bosagora validator node must be part of at least one quorum slice. An individual validator node can however appear in multiple quorum slices. Using quorum slices of trusted nodes not only produces quicker consensus but also ensures greater stability and reliability. Because these trusted nodes carry more weight in reaching consensus, even if a bad actor were to add a million malicious nodes to the network, it won\u2019t have any effect unless they can convince a critical mass of nodes to include them in their quorum slices.","title":"Quorum Slicing"},{"location":"12-quorums/#quorum-balancing","text":"The problem with letting validators manually configure quorums is the opportunity for bias and centralization. This is the situation with SCP. The Bosagora team addressed this shortcoming by automating the quorum creation process which is referred to as quorum balancing . Quorum balancing helps everyone participate as a validator and is essential to realize a truly open membership. The idea is to make quorum configuration completely automated so there is no need for manual quorum configuration. Bosagora uses the set of all registered validators to automatically generate each node\u2019s quorum set. This ensures the quorum configuration is sufficiently decentralized. How does Bosagora ensure fairness in the configuration process? By using the pre-imaging technology from the consensus protocol to derive a randomness seed. This seed is then used as input to a deterministic pseudo-random number generator (PRNG). The PRNG then generates a specific sequence of numbers for a given seed (which ensures verifiability). This seed is then used to introduce randomness into the quorum. To further ensure fairness and randomness, the quorums are shuffled at specified intervals. This activity is referred to as quorum rebalancing . Currently, quorum rebalancing happens every hour.","title":"Quorum Balancing"},{"location":"13-flash-layer/","text":"Flash Layer The Problem The blockchain has a scalability issue. On the one hand, for security and stability, you want as many nodes as possible in the network. On the other hand, reaching a network-wide consensus requires every update on the blockchain to be broadcasted to every node. This is a serious challenge to reaching credit card transaction throughput levels that can reach tens of thousands per second. The main problem with scaling blockchain is the fact that every transaction is public and must be validated by all network nodes. But there is a way around that. The Solution The solution to the blockchain scalability challenge is to not make every transaction public. Frequently in business, two parties will do multiple transactions between them before they need to terminate that piece of business. Being able to take a multitude of transactions \u201coff-chain\u201d and onto layer 2 is a way to dramatically improve the transaction speed and therefore scalability of the blockchain. And that is precisely how Bosagora addresses the scalability issue. Bosagora uses payment channels which enable two parties to carry out everyday transactions between them without requiring approval from the blockchain. Then they only do net settlement of all their transactions on-chain when needed. Payment channels use a second-layer payment protocol built on top of the Bosagora network. They are opened with an on-chain transaction and remain open until one or both parties decide to close the channel. While the channel is open, all communication happens only between the two parties. At any point, either party has the means to close the channel with the most recent balance they mutually agreed on. In case of a dispute, the network is used as an arbiter to resolve the dispute. Payment channels only allow payments between two parties. The benefits of these payment channels include the following: Users do not need to open channels to every merchant individually Fees are significantly smaller than on-chain fees Payments are almost instantaneous. No waiting time for block confirmations. Scales to millions of users, and near-infinite transactions/second The idea of payment channels led to the Bosagora Flash Layer . Flash Layer The Bosagora Flash Layer implements an improved version of Eltoo channels. Eltoo is an update and settlement layer for second-layer payment channels like that used on Bosagora. The following sections explain how the Flash Layer works Opening a Channel Channels are opened by the peer that provides the initial funds. This peer is referred to as the funding peer . Channels are marked as open with an on-chain transaction called the funding transaction . With funding transactions, the funds are locked with a multi-sig. The funds can only be consumed in a manner that both peers mutually agree on and provide the signatures for. The steps are as follows: The funding peer first creates the funding transaction and proposes opening a new channel to its peer, because publishing the funding transaction without any communication with the peer may result in losing the allocated funds forever. The peer either rejects the channel according to its own configuration or accepts it, which triggers a set of additional steps before the channel is actually opened. Before the funding peer can publish the funding transaction, two off-chain transactions are created and the peers exchange their signatures for them. These transactions are called trigger and settlement . They give both parties the means to close the channel at any point. The trigger transaction is an off-chain transaction that spends the funds from the funding transaction. If published to the blockchain, it begins a non-collaborative channel close . Once the funding peer collects the required signatures for trigger and settlement transactions, it publishes the funding transaction to the Bosagora network. Both peers continuously monitor the blockchain for externalization of the funding transaction. Externalization of the funding transaction marks the opening of the channel on the blockchain and the Flash nodes start accepting payments on the newly opened channel after that. Since the funding transaction is no different than any other transaction, no nodes other than the parties involved are aware of the new channel. Similar to layer-1, the Flash Layer utilizes a gossip protocol to ensure the optimal operation of the network. Nodes gossip the necessary information about the newly opened channel to their known network peers. Payments Payments are the exchange of off-chain transactions that happen between the channel peers. Payments update the channel balance , which is the distribution of funds between parties. Each payment creates an update and a settlement transaction pair. Update transactions attach to the trigger transaction or to a previous update transaction. These update transactions are only published to the blockchain in case of an uncollaborative channel close. Settlement transactions may only attach to exactly the previous trigger or update transaction. Settlement transactions contain the current balance distribution between the channel parties. Settlement transactions cannot be externalized until their relative time lock expires. Once they are externalized, that marks the close of the channel. See the figure below for a visual depiction of a representative transaction. Sequence IDs In other layer-2 implementations like Lightning Network of Bitcoin, if one of the parties tries to cheat and close the channel with an outdated balance, the other peer has the right to penalize them and get all the funds in the channel. Bosagora solves this using an improved Eltoo implementation with sequence IDs. Each trigger and update transaction has a locked script like the one below. OP.IF <update-tx-key> <min-sequence-id> OP.VERIFY_SEQ_SIG OP.ELSE <relative-timelock> OP.VERIFY_UNLOCK_AGE <settlement-tx-key> <sequence-id> OP.VERIFY_SEQ_SIG OP.ENDIF The IF branch ensures that only an update transaction with a newer sequence id can consume the given trigger/update transaction, without any timelock. The ELSE branch allows the corresponding settlement transaction to consume the trigger/update transaction after the timelock expires. With each update/trigger transaction, a new timelock starts, allowing the other party to override it with a newer update transaction if they have one. This scheme ensures that nodes have enough time to overrule any non-collaborative channel close attempt with a newer update transaction. In the current version of the Bosagora Flash Layer, timelocks are set for 16 blocks, which on average gives a little less than 3 hours of time for nodes to react to a non-collaborative channel close. Closing a channel Similar to opening a channel, closing a channel requires on-chain transactions. The ideal way to close a channel is the collaborative channel close . This requires both parties to be online and agree on a closing balance. In this case, the peers create a closing transaction that spends the funding transaction without any trigger/update/settlement transactions in between. This enables instantly closing the channel without waiting on any timelocks and with minimal on-chain fees. A Closing transaction is an on-chain transaction that spends the funding transaction and pays peers their share of the initial funds. Once externalized, it marks the closing of the channel. In situations where a peer is unresponsive or the peers can\u2019t agree on a closing balance, a non-collaborative channel close is initiated by one of the peers by publishing the trigger transaction. Externalization of the trigger transaction starts the countdown on a timelock. During the timelock, nodes can publish newer update transactions, if they have any. After the timelock expires, the corresponding settlement transaction is published and externalization of that marks the channel as closed. Multi-hop payments The Bosagora Flash Layer allows multi-hop payments . The Flash Layer finds a payment route to the merchant through a series of existing channels as shown in the graphic below. The payment is then routed through the channels. This eliminates the need to open a channel between each flash node. Multihop payments require the following six steps: Pathfinding Onion encryption Path probing Channel updates Invoices Trustless payment forwarding All six steps are discussed in detail below. Path finding The first step in supporting multi-hop payments is finding a series of channels that can route the required amount from payer to payee. The Gossip protocol in the Flash Layer tries to make sure that all nodes are aware of all open channels in the network. Using a graph of all the open channels, the originating node tries to minimize the total fees along the path while making sure that channels have enough capacity to forward the amount that it is trying to route. The pathfinding algorithm also allocates fees to each node on the path for the liquidity they provide. Onion encryption For privacy, all communications for multi-hop payments are onion encrypted , meaning that the packet is encrypted multiple times at the originating node. Each intermediate node decrypts it partially and forwards the packet to the next node by using the information revealed to it. In this manner, no unnecessary information is revealed to any nodes in between, providing the maximum amount of privacy for all parties. In the case of an error, an error message is propagated back to the originating node. But this time, since no nodes have the full path back to the origin, the packet is obfuscated, instead of encrypted, in a way that only the originating node can de-obfuscate it. The privacy of the parties is protected even in an error state. Path probing Since paths can fail to forward the payment, there must be a way to retry a different path in such a circumstance. The Flash Layer, and the channels in the layer, are highly dynamic, so there could be multiple reasons why a payment fails. When an error occurs, the erroring node sends a message back to the originating node indicating why it failed. Using this information, the originating node either decides to retry with a different path or marks the payment as a failure and gives up. Channel updates Some public properties of the channels can be updated throughout the channel\u2019s lifetime with a channel update message gossiped to the Flash Layer. Update messages carry critical information for pathfinding such as the most recent fee rate that the channel has. Invoices An invoice represents a payment between two nodes and is used to keep track of the payments. Invoices are generated by the payee and sent to the payer through some medium (QR codes, NFC, etc.) outside of the Flash Layer. Trustless payment forwarding For multi-hop payments to work in a decentralized system, there must be a way to forward the payment in a trustless way. In the Flash Layer, this is made possible with the use of Hashed Timelock Contracts (HTLC). HTLCs allow for a payment to be redeemed only if a secret is revealed, otherwise, the payment is revoked at the end of a timelock. In the example above, Party A generates a random secret and creates an HTLC with a timelock of 6 blocks and the hash of the newly generated secret. If Party A reveals the secret to Party B, Party B can redeem the funds using that secret or Party A can get back the funds after the timelock of 6 blocks expires. This 9-step sequence is depicted in the graphic below: (1) The payee generates a secret and passes the hash of the secret to the payee in the invoice. (2 \u2013 5) Using that hash, HTLCs are created at each hop of the path, locking the funds in each channel until a timeout expires. Once the chain of HTLCs reaches the payee, it has to reveal the random secret to the previous node to be able to get the payment. (6 \u2013 9) This creates a chain reaction of the secret being revealed to each node on the path until it reaches the originating node as a confirmation of a successful payment. Once all HTLCs are resolved, intermediate nodes are left with a small profit they made off their fee. If for some reason, a payee never reveals the secret, all HTLCs on the path expire, one by one, starting from the node furthest away from the originating node and all nodes receive their funds back. Multi-hop payments enable the Flash Layer to scale to near-infinite, low fee and almost instantaneous transactions per second trustlessly, while also providing incentive for parties to operate a Flash node and provide liquidity to the network.","title":"Flash Layer"},{"location":"13-flash-layer/#flash-layer","text":"","title":"Flash Layer"},{"location":"13-flash-layer/#the-problem","text":"The blockchain has a scalability issue. On the one hand, for security and stability, you want as many nodes as possible in the network. On the other hand, reaching a network-wide consensus requires every update on the blockchain to be broadcasted to every node. This is a serious challenge to reaching credit card transaction throughput levels that can reach tens of thousands per second. The main problem with scaling blockchain is the fact that every transaction is public and must be validated by all network nodes. But there is a way around that.","title":"The Problem"},{"location":"13-flash-layer/#the-solution","text":"The solution to the blockchain scalability challenge is to not make every transaction public. Frequently in business, two parties will do multiple transactions between them before they need to terminate that piece of business. Being able to take a multitude of transactions \u201coff-chain\u201d and onto layer 2 is a way to dramatically improve the transaction speed and therefore scalability of the blockchain. And that is precisely how Bosagora addresses the scalability issue. Bosagora uses payment channels which enable two parties to carry out everyday transactions between them without requiring approval from the blockchain. Then they only do net settlement of all their transactions on-chain when needed. Payment channels use a second-layer payment protocol built on top of the Bosagora network. They are opened with an on-chain transaction and remain open until one or both parties decide to close the channel. While the channel is open, all communication happens only between the two parties. At any point, either party has the means to close the channel with the most recent balance they mutually agreed on. In case of a dispute, the network is used as an arbiter to resolve the dispute. Payment channels only allow payments between two parties. The benefits of these payment channels include the following: Users do not need to open channels to every merchant individually Fees are significantly smaller than on-chain fees Payments are almost instantaneous. No waiting time for block confirmations. Scales to millions of users, and near-infinite transactions/second The idea of payment channels led to the Bosagora Flash Layer .","title":"The Solution"},{"location":"13-flash-layer/#flash-layer_1","text":"The Bosagora Flash Layer implements an improved version of Eltoo channels. Eltoo is an update and settlement layer for second-layer payment channels like that used on Bosagora. The following sections explain how the Flash Layer works","title":"Flash Layer"},{"location":"13-flash-layer/#opening-a-channel","text":"Channels are opened by the peer that provides the initial funds. This peer is referred to as the funding peer . Channels are marked as open with an on-chain transaction called the funding transaction . With funding transactions, the funds are locked with a multi-sig. The funds can only be consumed in a manner that both peers mutually agree on and provide the signatures for. The steps are as follows: The funding peer first creates the funding transaction and proposes opening a new channel to its peer, because publishing the funding transaction without any communication with the peer may result in losing the allocated funds forever. The peer either rejects the channel according to its own configuration or accepts it, which triggers a set of additional steps before the channel is actually opened. Before the funding peer can publish the funding transaction, two off-chain transactions are created and the peers exchange their signatures for them. These transactions are called trigger and settlement . They give both parties the means to close the channel at any point. The trigger transaction is an off-chain transaction that spends the funds from the funding transaction. If published to the blockchain, it begins a non-collaborative channel close . Once the funding peer collects the required signatures for trigger and settlement transactions, it publishes the funding transaction to the Bosagora network. Both peers continuously monitor the blockchain for externalization of the funding transaction. Externalization of the funding transaction marks the opening of the channel on the blockchain and the Flash nodes start accepting payments on the newly opened channel after that. Since the funding transaction is no different than any other transaction, no nodes other than the parties involved are aware of the new channel. Similar to layer-1, the Flash Layer utilizes a gossip protocol to ensure the optimal operation of the network. Nodes gossip the necessary information about the newly opened channel to their known network peers.","title":"Opening a Channel"},{"location":"13-flash-layer/#payments","text":"Payments are the exchange of off-chain transactions that happen between the channel peers. Payments update the channel balance , which is the distribution of funds between parties. Each payment creates an update and a settlement transaction pair. Update transactions attach to the trigger transaction or to a previous update transaction. These update transactions are only published to the blockchain in case of an uncollaborative channel close. Settlement transactions may only attach to exactly the previous trigger or update transaction. Settlement transactions contain the current balance distribution between the channel parties. Settlement transactions cannot be externalized until their relative time lock expires. Once they are externalized, that marks the close of the channel. See the figure below for a visual depiction of a representative transaction.","title":"Payments"},{"location":"13-flash-layer/#sequence-ids","text":"In other layer-2 implementations like Lightning Network of Bitcoin, if one of the parties tries to cheat and close the channel with an outdated balance, the other peer has the right to penalize them and get all the funds in the channel. Bosagora solves this using an improved Eltoo implementation with sequence IDs. Each trigger and update transaction has a locked script like the one below. OP.IF <update-tx-key> <min-sequence-id> OP.VERIFY_SEQ_SIG OP.ELSE <relative-timelock> OP.VERIFY_UNLOCK_AGE <settlement-tx-key> <sequence-id> OP.VERIFY_SEQ_SIG OP.ENDIF The IF branch ensures that only an update transaction with a newer sequence id can consume the given trigger/update transaction, without any timelock. The ELSE branch allows the corresponding settlement transaction to consume the trigger/update transaction after the timelock expires. With each update/trigger transaction, a new timelock starts, allowing the other party to override it with a newer update transaction if they have one. This scheme ensures that nodes have enough time to overrule any non-collaborative channel close attempt with a newer update transaction. In the current version of the Bosagora Flash Layer, timelocks are set for 16 blocks, which on average gives a little less than 3 hours of time for nodes to react to a non-collaborative channel close.","title":"Sequence IDs"},{"location":"13-flash-layer/#closing-a-channel","text":"Similar to opening a channel, closing a channel requires on-chain transactions. The ideal way to close a channel is the collaborative channel close . This requires both parties to be online and agree on a closing balance. In this case, the peers create a closing transaction that spends the funding transaction without any trigger/update/settlement transactions in between. This enables instantly closing the channel without waiting on any timelocks and with minimal on-chain fees. A Closing transaction is an on-chain transaction that spends the funding transaction and pays peers their share of the initial funds. Once externalized, it marks the closing of the channel. In situations where a peer is unresponsive or the peers can\u2019t agree on a closing balance, a non-collaborative channel close is initiated by one of the peers by publishing the trigger transaction. Externalization of the trigger transaction starts the countdown on a timelock. During the timelock, nodes can publish newer update transactions, if they have any. After the timelock expires, the corresponding settlement transaction is published and externalization of that marks the channel as closed.","title":"Closing a channel"},{"location":"13-flash-layer/#multi-hop-payments","text":"The Bosagora Flash Layer allows multi-hop payments . The Flash Layer finds a payment route to the merchant through a series of existing channels as shown in the graphic below. The payment is then routed through the channels. This eliminates the need to open a channel between each flash node. Multihop payments require the following six steps: Pathfinding Onion encryption Path probing Channel updates Invoices Trustless payment forwarding All six steps are discussed in detail below.","title":"Multi-hop payments"},{"location":"13-flash-layer/#path-finding","text":"The first step in supporting multi-hop payments is finding a series of channels that can route the required amount from payer to payee. The Gossip protocol in the Flash Layer tries to make sure that all nodes are aware of all open channels in the network. Using a graph of all the open channels, the originating node tries to minimize the total fees along the path while making sure that channels have enough capacity to forward the amount that it is trying to route. The pathfinding algorithm also allocates fees to each node on the path for the liquidity they provide.","title":"Path finding"},{"location":"13-flash-layer/#onion-encryption","text":"For privacy, all communications for multi-hop payments are onion encrypted , meaning that the packet is encrypted multiple times at the originating node. Each intermediate node decrypts it partially and forwards the packet to the next node by using the information revealed to it. In this manner, no unnecessary information is revealed to any nodes in between, providing the maximum amount of privacy for all parties. In the case of an error, an error message is propagated back to the originating node. But this time, since no nodes have the full path back to the origin, the packet is obfuscated, instead of encrypted, in a way that only the originating node can de-obfuscate it. The privacy of the parties is protected even in an error state.","title":"Onion encryption"},{"location":"13-flash-layer/#path-probing","text":"Since paths can fail to forward the payment, there must be a way to retry a different path in such a circumstance. The Flash Layer, and the channels in the layer, are highly dynamic, so there could be multiple reasons why a payment fails. When an error occurs, the erroring node sends a message back to the originating node indicating why it failed. Using this information, the originating node either decides to retry with a different path or marks the payment as a failure and gives up.","title":"Path probing"},{"location":"13-flash-layer/#channel-updates","text":"Some public properties of the channels can be updated throughout the channel\u2019s lifetime with a channel update message gossiped to the Flash Layer. Update messages carry critical information for pathfinding such as the most recent fee rate that the channel has.","title":"Channel updates"},{"location":"13-flash-layer/#invoices","text":"An invoice represents a payment between two nodes and is used to keep track of the payments. Invoices are generated by the payee and sent to the payer through some medium (QR codes, NFC, etc.) outside of the Flash Layer.","title":"Invoices"},{"location":"13-flash-layer/#trustless-payment-forwarding","text":"For multi-hop payments to work in a decentralized system, there must be a way to forward the payment in a trustless way. In the Flash Layer, this is made possible with the use of Hashed Timelock Contracts (HTLC). HTLCs allow for a payment to be redeemed only if a secret is revealed, otherwise, the payment is revoked at the end of a timelock. In the example above, Party A generates a random secret and creates an HTLC with a timelock of 6 blocks and the hash of the newly generated secret. If Party A reveals the secret to Party B, Party B can redeem the funds using that secret or Party A can get back the funds after the timelock of 6 blocks expires. This 9-step sequence is depicted in the graphic below: (1) The payee generates a secret and passes the hash of the secret to the payee in the invoice. (2 \u2013 5) Using that hash, HTLCs are created at each hop of the path, locking the funds in each channel until a timeout expires. Once the chain of HTLCs reaches the payee, it has to reveal the random secret to the previous node to be able to get the payment. (6 \u2013 9) This creates a chain reaction of the secret being revealed to each node on the path until it reaches the originating node as a confirmation of a successful payment. Once all HTLCs are resolved, intermediate nodes are left with a small profit they made off their fee. If for some reason, a payee never reveals the secret, all HTLCs on the path expire, one by one, starting from the node furthest away from the originating node and all nodes receive their funds back. Multi-hop payments enable the Flash Layer to scale to near-infinite, low fee and almost instantaneous transactions per second trustlessly, while also providing incentive for parties to operate a Flash node and provide liquidity to the network.","title":"Trustless payment forwarding"},{"location":"changelog/","text":"Changelog bosagora/agora v0.16.0 _ 2021-08-04 Improved logging, multiple minor crashes fixed, better libconsensus Major improvements since v0.15.0: The /validators endpoint will now longer return a 500 when called with height=0 ; Ledger.getValidators : Return only validators that are not yet slashed; Remove an ambiguous usage of PublicKey (instead of UTXO) in signature aggregation; Key mapping have been removed from the EnrollmentManager, reducing memory usage; BitMask: Fixed serialization to not duplicate the length field, fixing a DoS vector; Admin endpoints now require the use of TLS (HTTPS); Admin endpoints now support basic auth, which can be configured from the config file; Some logging statements have been adjusted, resulting in less noise being produced at Info level; Validator nodes that cannot enroll, regardless of the reason, will no longer crash on shutdown; SCP logging will now produce human-readable strings for node ID; SCP logging is now fully configurable, including trace / debug level, like any other logging system; UTXODB will now always return ordered UTXO; Renamed endpoint stats for GET /block_height from block_heigth to block_height ; v0.15.0 _ 2021-07-27 Signature fixes, flash fees, better stats & config Major improvements since v0.14.0: Blocks are not only signed after SCP's EXTERNALIZE, instead of COMMIT; block_interval_sec is now a parameter of consensus instead of node ; Flash: Funding tx fee and closing tx fees are now supported; Block stats will now always be generated, even when no block has been generated yet; v0.14.0 _ 2021-07-24 Guaranteed block time, integration fixes, many preimages, timer optimizations Major improvements since v0.13.0: Agora will now produce blocks at the right interval, even if empty; The agora_preimages_gauge stats entry has been renamed to agora_preimages_counter; Fixed the VoterCard signature scheme to only hash once, not twice; Fixed QR admin methods to not escape the returned string; Nodes will now generate a large (5M) of pre-images on startup, allowing them to stay validators for longer timer before switching UTXOs; Various timers used for recurring tasks have been optimized to only fire when necessary, instead of a fixed regular interval; Agora will now longer automatically sign blocks when catching up, to avoid potential double signatgure issues; v0.13.0 _ 2021-07-19 Signature adjustment, DoS prevent, Talos & SCP overhaul Major improvements since v0.12.0: Fixed a bug that allowed validators to sign an extra block before slashing actually happened; SCP layer now requires C++17 support; Inconsistency between ConsensusParams' ValidatorCycle and the Genesis block's will now error out; Fixed a bug which would lead to the Logger throwing when being called from SCP in some rare cases; Fixed a bug which would crash the node (abort) if the Logger threw an Exception; Libconsensus: The validator set now include the validator's preimage; The SCP integration has been overhaul and greatly simplified, removing a lot of dead code; Nodes will only start gossipping transactions if they have a validator peer to avoid tx getting stuck; Nodes will now always keep connection to validators, regardless of min_peers; FullNode API now includes a handshake method which replaces getPublicKey as handshake method; Talos: Correctly show the error message if Agora returns an error; Talos: Update the config format to match current format; Stoa handlers have been combined in a single module; Outgoing requests now support proxy; Fixed a bug in the nomination protocol where a vote would change from yes to no when there were nodes to slash; Signatures can now only be added for the blocks that have been produced since the last payment; The bitfield in the BlockHeader used to record validators have been modified to unambiguously store the length; Fixed a DoS vector where a node could crash when asked invalid data; SCP now uses the UTXO as node ID instead of public key; Stoa: Block headers are now pushed when a new signature is received (block_header_updated handler); Fixed a DoS attack where a node would crash when receiving a specifically crafted signature; Fixed a DoS attack where a node would crash upon receiving alphanumeric but non-hex characters in large binary values; Added Swagger API specification to allow fuzzing the node; Added opt-out fuzzing component to the network integration tests; Talos: Improved dependency tree to reduce security risks; Talos: Fixed vulnerability with target=blank links; Talos: Improved first screen UX and fixed network address parsing; Talos now requires node 16; Flash: Add on-chain fees related endpoints to support fees in uncollaborating close attempts; Fixed a bug where signature catchup was dependent on the order of the returned items; Changed the admin interface methods ( loginQR , encryptionKeyQR ) to be GET instead of POST; Pre-images are now shared during SCP nomination to reduce the odds of slashing; Removed FullNode's getPreimage endpoint, obsoleted by getPreimages ; v0.12.0 _ 2021-06-17 Better stats, TxBuilder improvements and bugfix, /validators endpoint Major improvements since v0.11.0: The minimum required version of LDC / DUB are now 1.26.0 and 1.25.0, respectively; The genesis timestamp can now be configured as consensus.genesis_timestamp ; Configuring validator.slash_penalty_amount is no longer supported; The stats now include the genesis timestamp; TxBuilder has been simplified, with multiple parameters of sign now being functions; Flash: The remaining funds in a funding tx will now be properly credited back; Registry payload that fail signature validation will now be more verbose and prominent; A bug where the wrong key was used to verify the signature of a registry payload, leading to rejecting valid registry payload, has been fixed. All endpoints now provide endpoint stats (some were previously missing); Nodes now expose GET /validators[?height=$height] to get the list of validators at a given height; TxBuilder now properly sorts the inputs, fixing a bug where it would sign the wrong input; Along with many internal changes to improve efficiency and reduce the risk of error. v0.11.0 _ 2021-06-10 Better Flash notifications, runtime logger configuration, SCP cleanup Major changes since v0.10.0: Flash: Discovery now includes Channel updates; Flash: Channels are now gossipped to new peers; Flash: Fixed a possible race condition between state change and notification to listener; Quorum balancing: The hash used as seed is now that of the externalized block, instead of the ledger state; TxBuilder now correctly orders inputs when creating a transaction; The SCP internals have been revamped, leading to lower memory footprint and easier integration; Validator.receiveEnvelope now longer blocks, it uses a queue for processing envelope asynchronously instead; Loggers can now be dynamically reconfigured through an endpoint in the admin interface; Serialization now always serialize to little endian regardless of the host; Multiple stability improvements / race conditions fixed; v0.10.0 _ 2021-06-06 Extra syntax checks on lock script, improved Votera support, HTTPS Major changes since v0.9.0: Admin interface now use the right pre-image to generate the encryption key for Votera; Transaction payload is now a simple array instead of a struct (breaking change for JSON serialization); Agora will now perform additional syntaxical validation on the lock script to ensure it is not malformed; Votera: Admin interface now include signature and public key with voter card; Disabled a new upstream behavior to prevent double destruction of GC-allocated object; Better diagnostics will be provided when Agora fails to start for abnormal reasons, such as corrupted disk state; Logger configuration will now propagate to child logger by default; Discovery / registry registration task is now more efficient; Support for HTTPS communication has been added; Consensus: Validators will now reject blocks with non-monotonic missing validators; v0.9.0 _ 2021-06-01 Passive slashing, per-output type, better setup and debug experience Major changes since v0.8.1: Pre-images are now used to generate block signatures Block signatures are now based on pre-images for the \"signature noise\" derivation. This implements one of the aspect of Agora's passive slashing policy, which is that signing two blocks for the same height reveal a validator's private key. Transaction type has been moved to Output Previously, transactions had a \"type\" field that would indicate the type of its output: payment (the default), freeze, or coinbase. This created issues as payment and freeze needed to be mixed (e.g. to avoid creating a refund transaction that was frozen). The type field is now part of the Output , and may be extended in the future. Multiple Talos (setup interface) bug fixes The setup interface had a few issues, where some field would be empty when run in a particular way, making navigating between menus impossible. Those issues have been fixed and the interface now works as expected on all devices. Agora will now dynamically export its symbol Agora now use the export-dynamic linker option by default, which should result in proper stack traces on Alpine Linux (and potentially other platforms), at the cost of slightly bigger binary. Stripping the binary will still work. v0.8.1 _ 2021-05-26 Always enable TRACY_ON_DEMAND This is an internal fix that might reduce memory usage for some clients. v0.8.0 _ 2021-05-26 Random seed correction, sorted transactions, RBF Notable changes since last release (v0.7.1): Well known keypairs have been updated (this affect users running test networks); An intermittent error in UTXODB will no longer be silence, instead the node will properly report it; Nodes will now replace transactions in their TxPool if it fulfill certain conditions (e.g. higher fee); Random seed calculation was wrong (involved an extra Hash.init parameter) and has been fixed; Transactions will now sort their inputs and outputs; Ledger will now do a full reset if the validator set is empty, regardless of the UTXOSet being non-empty; v0.7.1 _ 2021-05-20 Improved logging for nomination This release mainly contains enhancements on logging during the nomination phase, along with a couple internal improvements. v0.7.0 _ 2021-05-17 Major SCP upgrade Changes since v0.6.1: SCP has been upgraded from v11.2.0 (2019-06-26) to v16.0.0 (2021-04-08). v0.6.1 _ 2021-05-14 Minor CI fix on tags push This release fixes a minor issue that triggered when a tag was pushed. One of the test would previously fail to run because it expected a different git object. v0.6.0 _ 2021-05-14 Absolute PreImage offsets, greatly improved Flash API, transaction fees Notable changes since the last release: Validator now authenticate themselves upon connecting to one another; The random seed algorithm has been changed to be simpler; The node hashing algorithm has been changed to be stable at a given height/state; Many bugs in the shutdown procedure have been fixed, and things should never hang now; The consensus protocol now supports a minimum fee; Default development compiler is now LDC 1.26 (LDC 1.25 works for building, but not in unittest mode); Windows builds have been disabled due to limitations in the CI memory capacity; PreImages now uses absolute index (height) instead of relative index (relative to enrollment); The Flash layer now supports managing multiple keys from the same node; It is now possible to list flash channels through the API; The node now exposes 4 config parameters to control and limit transactions propagation; Flash: Settlement is now always published after timeout is reached; Talos, the setup interface, is now integrated in Agora and can be started with --initialize=address_to_bind ; The API now allows to get detailes informations about a list of Flash channels; The Flash control API can now be configured to bind to a specific address/port; Rules for nomination has been improved to take fees into account and better handle time differences; Loggers can now be reconfigured dynamically through the admin interface; Nodes will now prioritize their own Enrollment instead of waiting to hear back from other nodes; DataPayload now uses Base64 for the REST API; DataPayload.data was renamed to bytes ; SCP is now built with clang++ on all platforms; The random seed check no longer mistakenly uses the node state over the block state; v0.5.0 _ 2021-04-22 Fixed nomination timer, improved flash API Network discovery period is now configurable ( node.network_discovery_interval_secs ); Nomination interval is now configurable ( validator.nomination_interval , in seconds); Nomination interval is now 5s by default, up from 1s; this should improve liveness; Flash can now use a registry; Flash API now includes onRequestedChannelOpen to query if a node will accept a channel open; Fixed a race condition preventing envelopes with valid signature to be accepted after externalization; Periodic catchup will now longer ask for signatures from slashed nodes; Flash: changeFee was only implemented in test, moved to production; Vanity miner now supports Bech32, and well-known keypairs have been changed accordingly; The node will now stop nominating as soon as it starts shutting down; v0.4.1 _ 2021-04-19 Minor build script fixes Fixes an issue with the build script that led to the version being rendered incorrectly. v0.4.0 _ 2021-04-19 Configurable logger, readable SQL databases UTXO set is now stored in utxo database, validator set in validator table; Most tables now use text fields instead of binary ones; UTXO's pubkey_hash field is now called pubkey ; Nomination protocol now takes into account missing validator pre-images; Some log messages have been cleaned up to be less confusing / alarming; Loggers can now be configured individually in the config file; v0.3.0 _ 2021-04-16 Improved Flash with Wallet API, better catch-up, database restructuring Vibe.d & other libraries have been updated to remove some networking bugs; Flash layer documentation and tests have been enhanced; Validators will no longer re-enroll at every block during catchup, only the recent ones; The Flash layer API has been extended for wallet usage; Payment paths now have configurable timeouts and better error reporting; Validators will now properly shut down and finalize all objects without error; Pre-image member 'enroll_key' has been renamed to 'utxo'; Node state have been unified in two databases, 'stateDB' and 'cacheDB', instead of multiple scattered ones; Logging has been improved, especially w.r.t. block signatures; Default and example values for various configuration parameters have been adjusted to be more realistic; A block storage corruption preventing nodes from restarting has been fixed; Validators will no longer ban validators, even if they are not responding; The logic around pre-images has been improved, leading to more tolerance in what is accepted; BitBlob has been updated to v2.0.0, removing a DoS vector when using the REST interface; Flash retry logic now uses a configurable exponential backoff algorithm instead of simple retry; The 'random_seed' member of 'Enrollment' has been renamed to commitment; Flash: Channel gossipping has been improved; Flash: Channel updates are now sequenced, preventing replays; Nodes will no longer query already externalized blocks from nodes when retrying after seeing an invalid block; TxBuilder is now available in its own module for client code to use; Flash: Onion payload has been simplified and some unused fields have been removed; Flash: Error messages are now authenticated (and ignored if not coming from a peer); Flash: A channel notification API is now available (e.g. onChannelNotify , monitorBlockchain ...); Name registry: Added CLI argument to set verbose mode; Flash: Make sure Payee sets enough lock_time; Flash: Channel closing has been improved; Congress: Voter card's expiry now comes with ISO8601 suffix; Agora can now listen to multiple interfaces, not just one, allowing to bind to e.g. different IPs; Nodes will now longer fetch all pre-images during catchup, only the latest ones; Nodes will no longer nominate data that would slash all validators; All commits since v0.2.0 v0.2.0 _ 2021-03-30 Flash layer, slashing, block signatures, Bech32, Schnorr everywhere, and more The following is a non-exhaustive list of major changes since last release: Agora now stores version information ( agora --version ); Transaction Fees and Coinbase have been added; Block signatures are now fetched during periodic catchup; SCP nomination is now based on hashes of transaction instead of the whole object; Nodes that do not reveal pre-images will now get slashed; Nodes are now better at enrolling (retry, delays, etc...); A beta version of the Flash layer is now available; Full nodes now have a simpler REST endpoint to query a single block; Block storage has been improved; Test networks can now run on less than 6 validators; The crypto and serialization code are now the4ir own libraries; Periodic catch up has been improved; Allow refund outputs of freezing tx to not be frozen if < 40k; Nodes will rather crash than slash themselves; The minimum required DUB & LDC version is now v1.25.0; A basic Tracy integration has been added; Agora memory usage can now be profiled at runtime via an instrumented GC; All transactions are now signed using Schnorr, Ed25519 is not used anymore; Agora now works better with its network registry, reducing the need for manual configuration; Blocks will now store a time offset from Genesis instead of an absolute timestamp; Key pair will now perform additional safety and validity checks; PreImage implementation have been improved; An endpoint to validate the config file is now available for the setup interface; Onion routing is used in the Flash layer; Agora will now store its state in a more readable manner in the DB; Flash persistence has been implemented; Logger overhead has been reduced; Public keys are now encoded using Bech32 rather than Stellar-style format; All commits since v0.1.0 v0.1.0 _ 2021-01-08 Pre-slashing alpha version This release is the first tagged alpha version of Agora. Agora has been deployed to a test environment for months now, however no tag has existed yet. In order to allow for the development of a more stable versioning and deployment scheme, a first tag needs to be introduced.","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#bosagoraagora","text":"","title":"bosagora/agora"},{"location":"changelog/#v0160-_-2021-08-04","text":"Improved logging, multiple minor crashes fixed, better libconsensus Major improvements since v0.15.0: The /validators endpoint will now longer return a 500 when called with height=0 ; Ledger.getValidators : Return only validators that are not yet slashed; Remove an ambiguous usage of PublicKey (instead of UTXO) in signature aggregation; Key mapping have been removed from the EnrollmentManager, reducing memory usage; BitMask: Fixed serialization to not duplicate the length field, fixing a DoS vector; Admin endpoints now require the use of TLS (HTTPS); Admin endpoints now support basic auth, which can be configured from the config file; Some logging statements have been adjusted, resulting in less noise being produced at Info level; Validator nodes that cannot enroll, regardless of the reason, will no longer crash on shutdown; SCP logging will now produce human-readable strings for node ID; SCP logging is now fully configurable, including trace / debug level, like any other logging system; UTXODB will now always return ordered UTXO; Renamed endpoint stats for GET /block_height from block_heigth to block_height ;","title":"v0.16.0 _ 2021-08-04"},{"location":"changelog/#v0150-_-2021-07-27","text":"Signature fixes, flash fees, better stats & config Major improvements since v0.14.0: Blocks are not only signed after SCP's EXTERNALIZE, instead of COMMIT; block_interval_sec is now a parameter of consensus instead of node ; Flash: Funding tx fee and closing tx fees are now supported; Block stats will now always be generated, even when no block has been generated yet;","title":"v0.15.0 _ 2021-07-27"},{"location":"changelog/#v0140-_-2021-07-24","text":"Guaranteed block time, integration fixes, many preimages, timer optimizations Major improvements since v0.13.0: Agora will now produce blocks at the right interval, even if empty; The agora_preimages_gauge stats entry has been renamed to agora_preimages_counter; Fixed the VoterCard signature scheme to only hash once, not twice; Fixed QR admin methods to not escape the returned string; Nodes will now generate a large (5M) of pre-images on startup, allowing them to stay validators for longer timer before switching UTXOs; Various timers used for recurring tasks have been optimized to only fire when necessary, instead of a fixed regular interval; Agora will now longer automatically sign blocks when catching up, to avoid potential double signatgure issues;","title":"v0.14.0 _ 2021-07-24"},{"location":"changelog/#v0130-_-2021-07-19","text":"Signature adjustment, DoS prevent, Talos & SCP overhaul Major improvements since v0.12.0: Fixed a bug that allowed validators to sign an extra block before slashing actually happened; SCP layer now requires C++17 support; Inconsistency between ConsensusParams' ValidatorCycle and the Genesis block's will now error out; Fixed a bug which would lead to the Logger throwing when being called from SCP in some rare cases; Fixed a bug which would crash the node (abort) if the Logger threw an Exception; Libconsensus: The validator set now include the validator's preimage; The SCP integration has been overhaul and greatly simplified, removing a lot of dead code; Nodes will only start gossipping transactions if they have a validator peer to avoid tx getting stuck; Nodes will now always keep connection to validators, regardless of min_peers; FullNode API now includes a handshake method which replaces getPublicKey as handshake method; Talos: Correctly show the error message if Agora returns an error; Talos: Update the config format to match current format; Stoa handlers have been combined in a single module; Outgoing requests now support proxy; Fixed a bug in the nomination protocol where a vote would change from yes to no when there were nodes to slash; Signatures can now only be added for the blocks that have been produced since the last payment; The bitfield in the BlockHeader used to record validators have been modified to unambiguously store the length; Fixed a DoS vector where a node could crash when asked invalid data; SCP now uses the UTXO as node ID instead of public key; Stoa: Block headers are now pushed when a new signature is received (block_header_updated handler); Fixed a DoS attack where a node would crash when receiving a specifically crafted signature; Fixed a DoS attack where a node would crash upon receiving alphanumeric but non-hex characters in large binary values; Added Swagger API specification to allow fuzzing the node; Added opt-out fuzzing component to the network integration tests; Talos: Improved dependency tree to reduce security risks; Talos: Fixed vulnerability with target=blank links; Talos: Improved first screen UX and fixed network address parsing; Talos now requires node 16; Flash: Add on-chain fees related endpoints to support fees in uncollaborating close attempts; Fixed a bug where signature catchup was dependent on the order of the returned items; Changed the admin interface methods ( loginQR , encryptionKeyQR ) to be GET instead of POST; Pre-images are now shared during SCP nomination to reduce the odds of slashing; Removed FullNode's getPreimage endpoint, obsoleted by getPreimages ;","title":"v0.13.0 _ 2021-07-19"},{"location":"changelog/#v0120-_-2021-06-17","text":"Better stats, TxBuilder improvements and bugfix, /validators endpoint Major improvements since v0.11.0: The minimum required version of LDC / DUB are now 1.26.0 and 1.25.0, respectively; The genesis timestamp can now be configured as consensus.genesis_timestamp ; Configuring validator.slash_penalty_amount is no longer supported; The stats now include the genesis timestamp; TxBuilder has been simplified, with multiple parameters of sign now being functions; Flash: The remaining funds in a funding tx will now be properly credited back; Registry payload that fail signature validation will now be more verbose and prominent; A bug where the wrong key was used to verify the signature of a registry payload, leading to rejecting valid registry payload, has been fixed. All endpoints now provide endpoint stats (some were previously missing); Nodes now expose GET /validators[?height=$height] to get the list of validators at a given height; TxBuilder now properly sorts the inputs, fixing a bug where it would sign the wrong input; Along with many internal changes to improve efficiency and reduce the risk of error.","title":"v0.12.0 _ 2021-06-17"},{"location":"changelog/#v0110-_-2021-06-10","text":"Better Flash notifications, runtime logger configuration, SCP cleanup Major changes since v0.10.0: Flash: Discovery now includes Channel updates; Flash: Channels are now gossipped to new peers; Flash: Fixed a possible race condition between state change and notification to listener; Quorum balancing: The hash used as seed is now that of the externalized block, instead of the ledger state; TxBuilder now correctly orders inputs when creating a transaction; The SCP internals have been revamped, leading to lower memory footprint and easier integration; Validator.receiveEnvelope now longer blocks, it uses a queue for processing envelope asynchronously instead; Loggers can now be dynamically reconfigured through an endpoint in the admin interface; Serialization now always serialize to little endian regardless of the host; Multiple stability improvements / race conditions fixed;","title":"v0.11.0 _ 2021-06-10"},{"location":"changelog/#v0100-_-2021-06-06","text":"Extra syntax checks on lock script, improved Votera support, HTTPS Major changes since v0.9.0: Admin interface now use the right pre-image to generate the encryption key for Votera; Transaction payload is now a simple array instead of a struct (breaking change for JSON serialization); Agora will now perform additional syntaxical validation on the lock script to ensure it is not malformed; Votera: Admin interface now include signature and public key with voter card; Disabled a new upstream behavior to prevent double destruction of GC-allocated object; Better diagnostics will be provided when Agora fails to start for abnormal reasons, such as corrupted disk state; Logger configuration will now propagate to child logger by default; Discovery / registry registration task is now more efficient; Support for HTTPS communication has been added; Consensus: Validators will now reject blocks with non-monotonic missing validators;","title":"v0.10.0 _ 2021-06-06"},{"location":"changelog/#v090-_-2021-06-01","text":"Passive slashing, per-output type, better setup and debug experience Major changes since v0.8.1: Pre-images are now used to generate block signatures Block signatures are now based on pre-images for the \"signature noise\" derivation. This implements one of the aspect of Agora's passive slashing policy, which is that signing two blocks for the same height reveal a validator's private key. Transaction type has been moved to Output Previously, transactions had a \"type\" field that would indicate the type of its output: payment (the default), freeze, or coinbase. This created issues as payment and freeze needed to be mixed (e.g. to avoid creating a refund transaction that was frozen). The type field is now part of the Output , and may be extended in the future. Multiple Talos (setup interface) bug fixes The setup interface had a few issues, where some field would be empty when run in a particular way, making navigating between menus impossible. Those issues have been fixed and the interface now works as expected on all devices. Agora will now dynamically export its symbol Agora now use the export-dynamic linker option by default, which should result in proper stack traces on Alpine Linux (and potentially other platforms), at the cost of slightly bigger binary. Stripping the binary will still work.","title":"v0.9.0 _ 2021-06-01"},{"location":"changelog/#v081-_-2021-05-26","text":"Always enable TRACY_ON_DEMAND This is an internal fix that might reduce memory usage for some clients.","title":"v0.8.1 _ 2021-05-26"},{"location":"changelog/#v080-_-2021-05-26","text":"Random seed correction, sorted transactions, RBF Notable changes since last release (v0.7.1): Well known keypairs have been updated (this affect users running test networks); An intermittent error in UTXODB will no longer be silence, instead the node will properly report it; Nodes will now replace transactions in their TxPool if it fulfill certain conditions (e.g. higher fee); Random seed calculation was wrong (involved an extra Hash.init parameter) and has been fixed; Transactions will now sort their inputs and outputs; Ledger will now do a full reset if the validator set is empty, regardless of the UTXOSet being non-empty;","title":"v0.8.0 _ 2021-05-26"},{"location":"changelog/#v071-_-2021-05-20","text":"Improved logging for nomination This release mainly contains enhancements on logging during the nomination phase, along with a couple internal improvements.","title":"v0.7.1 _ 2021-05-20"},{"location":"changelog/#v070-_-2021-05-17","text":"Major SCP upgrade Changes since v0.6.1: SCP has been upgraded from v11.2.0 (2019-06-26) to v16.0.0 (2021-04-08).","title":"v0.7.0 _ 2021-05-17"},{"location":"changelog/#v061-_-2021-05-14","text":"Minor CI fix on tags push This release fixes a minor issue that triggered when a tag was pushed. One of the test would previously fail to run because it expected a different git object.","title":"v0.6.1 _ 2021-05-14"},{"location":"changelog/#v060-_-2021-05-14","text":"Absolute PreImage offsets, greatly improved Flash API, transaction fees Notable changes since the last release: Validator now authenticate themselves upon connecting to one another; The random seed algorithm has been changed to be simpler; The node hashing algorithm has been changed to be stable at a given height/state; Many bugs in the shutdown procedure have been fixed, and things should never hang now; The consensus protocol now supports a minimum fee; Default development compiler is now LDC 1.26 (LDC 1.25 works for building, but not in unittest mode); Windows builds have been disabled due to limitations in the CI memory capacity; PreImages now uses absolute index (height) instead of relative index (relative to enrollment); The Flash layer now supports managing multiple keys from the same node; It is now possible to list flash channels through the API; The node now exposes 4 config parameters to control and limit transactions propagation; Flash: Settlement is now always published after timeout is reached; Talos, the setup interface, is now integrated in Agora and can be started with --initialize=address_to_bind ; The API now allows to get detailes informations about a list of Flash channels; The Flash control API can now be configured to bind to a specific address/port; Rules for nomination has been improved to take fees into account and better handle time differences; Loggers can now be reconfigured dynamically through the admin interface; Nodes will now prioritize their own Enrollment instead of waiting to hear back from other nodes; DataPayload now uses Base64 for the REST API; DataPayload.data was renamed to bytes ; SCP is now built with clang++ on all platforms; The random seed check no longer mistakenly uses the node state over the block state;","title":"v0.6.0 _ 2021-05-14"},{"location":"changelog/#v050-_-2021-04-22","text":"Fixed nomination timer, improved flash API Network discovery period is now configurable ( node.network_discovery_interval_secs ); Nomination interval is now configurable ( validator.nomination_interval , in seconds); Nomination interval is now 5s by default, up from 1s; this should improve liveness; Flash can now use a registry; Flash API now includes onRequestedChannelOpen to query if a node will accept a channel open; Fixed a race condition preventing envelopes with valid signature to be accepted after externalization; Periodic catchup will now longer ask for signatures from slashed nodes; Flash: changeFee was only implemented in test, moved to production; Vanity miner now supports Bech32, and well-known keypairs have been changed accordingly; The node will now stop nominating as soon as it starts shutting down;","title":"v0.5.0 _ 2021-04-22"},{"location":"changelog/#v041-_-2021-04-19","text":"Minor build script fixes Fixes an issue with the build script that led to the version being rendered incorrectly.","title":"v0.4.1 _ 2021-04-19"},{"location":"changelog/#v040-_-2021-04-19","text":"Configurable logger, readable SQL databases UTXO set is now stored in utxo database, validator set in validator table; Most tables now use text fields instead of binary ones; UTXO's pubkey_hash field is now called pubkey ; Nomination protocol now takes into account missing validator pre-images; Some log messages have been cleaned up to be less confusing / alarming; Loggers can now be configured individually in the config file;","title":"v0.4.0 _ 2021-04-19"},{"location":"changelog/#v030-_-2021-04-16","text":"Improved Flash with Wallet API, better catch-up, database restructuring Vibe.d & other libraries have been updated to remove some networking bugs; Flash layer documentation and tests have been enhanced; Validators will no longer re-enroll at every block during catchup, only the recent ones; The Flash layer API has been extended for wallet usage; Payment paths now have configurable timeouts and better error reporting; Validators will now properly shut down and finalize all objects without error; Pre-image member 'enroll_key' has been renamed to 'utxo'; Node state have been unified in two databases, 'stateDB' and 'cacheDB', instead of multiple scattered ones; Logging has been improved, especially w.r.t. block signatures; Default and example values for various configuration parameters have been adjusted to be more realistic; A block storage corruption preventing nodes from restarting has been fixed; Validators will no longer ban validators, even if they are not responding; The logic around pre-images has been improved, leading to more tolerance in what is accepted; BitBlob has been updated to v2.0.0, removing a DoS vector when using the REST interface; Flash retry logic now uses a configurable exponential backoff algorithm instead of simple retry; The 'random_seed' member of 'Enrollment' has been renamed to commitment; Flash: Channel gossipping has been improved; Flash: Channel updates are now sequenced, preventing replays; Nodes will no longer query already externalized blocks from nodes when retrying after seeing an invalid block; TxBuilder is now available in its own module for client code to use; Flash: Onion payload has been simplified and some unused fields have been removed; Flash: Error messages are now authenticated (and ignored if not coming from a peer); Flash: A channel notification API is now available (e.g. onChannelNotify , monitorBlockchain ...); Name registry: Added CLI argument to set verbose mode; Flash: Make sure Payee sets enough lock_time; Flash: Channel closing has been improved; Congress: Voter card's expiry now comes with ISO8601 suffix; Agora can now listen to multiple interfaces, not just one, allowing to bind to e.g. different IPs; Nodes will now longer fetch all pre-images during catchup, only the latest ones; Nodes will no longer nominate data that would slash all validators; All commits since v0.2.0","title":"v0.3.0 _ 2021-04-16"},{"location":"changelog/#v020-_-2021-03-30","text":"Flash layer, slashing, block signatures, Bech32, Schnorr everywhere, and more The following is a non-exhaustive list of major changes since last release: Agora now stores version information ( agora --version ); Transaction Fees and Coinbase have been added; Block signatures are now fetched during periodic catchup; SCP nomination is now based on hashes of transaction instead of the whole object; Nodes that do not reveal pre-images will now get slashed; Nodes are now better at enrolling (retry, delays, etc...); A beta version of the Flash layer is now available; Full nodes now have a simpler REST endpoint to query a single block; Block storage has been improved; Test networks can now run on less than 6 validators; The crypto and serialization code are now the4ir own libraries; Periodic catch up has been improved; Allow refund outputs of freezing tx to not be frozen if < 40k; Nodes will rather crash than slash themselves; The minimum required DUB & LDC version is now v1.25.0; A basic Tracy integration has been added; Agora memory usage can now be profiled at runtime via an instrumented GC; All transactions are now signed using Schnorr, Ed25519 is not used anymore; Agora now works better with its network registry, reducing the need for manual configuration; Blocks will now store a time offset from Genesis instead of an absolute timestamp; Key pair will now perform additional safety and validity checks; PreImage implementation have been improved; An endpoint to validate the config file is now available for the setup interface; Onion routing is used in the Flash layer; Agora will now store its state in a more readable manner in the DB; Flash persistence has been implemented; Logger overhead has been reduced; Public keys are now encoded using Bech32 rather than Stellar-style format; All commits since v0.1.0","title":"v0.2.0 _ 2021-03-30"},{"location":"changelog/#v010-_-2021-01-08","text":"Pre-slashing alpha version This release is the first tagged alpha version of Agora. Agora has been deployed to a test environment for months now, however no tag has existed yet. In order to allow for the development of a more stable versioning and deployment scheme, a first tag needs to be introduced.","title":"v0.1.0 _ 2021-01-08"},{"location":"wallet/01-wallet-guide/","text":"BOA Wallet Guide This document describes the different wallet options that are available to users of BOSAGORA who want to be able to send, receive and interact with BOA coins on the BOSAGORA blockchain. What is a Wallet? Wallet is an application that can be used to store accounts and transmit, receive, and track cryptocurrencies. An account consists of a public key, a secret key, and a name. The public key and the secret key are called key pairs. The public key is also used as the address of the account. The public key may be shared and displayed freely. When the other party sends a certain amount of cryptocurrency to the account, you need to know the account's receiving address. The public key can also be used to view specific information about your account, such as viewing balances, but there is no function to change or withdraw coins from your account. The secret key is used to sign all transactions that send or change cryptocurrency to another address. You can never share a secret key. If someone gains access to a secret key to an account, they can withdraw all the coins it contains. If the secret key for an account is lost, any coins that have been sent to that account's address are permanently lost. Supported Wallets BOSAGORA supports web wallet and mobile app wallet.","title":"BOA Wallet Guide"},{"location":"wallet/01-wallet-guide/#boa-wallet-guide","text":"This document describes the different wallet options that are available to users of BOSAGORA who want to be able to send, receive and interact with BOA coins on the BOSAGORA blockchain.","title":"BOA Wallet Guide"},{"location":"wallet/01-wallet-guide/#what-is-a-wallet","text":"Wallet is an application that can be used to store accounts and transmit, receive, and track cryptocurrencies. An account consists of a public key, a secret key, and a name. The public key and the secret key are called key pairs. The public key is also used as the address of the account. The public key may be shared and displayed freely. When the other party sends a certain amount of cryptocurrency to the account, you need to know the account's receiving address. The public key can also be used to view specific information about your account, such as viewing balances, but there is no function to change or withdraw coins from your account. The secret key is used to sign all transactions that send or change cryptocurrency to another address. You can never share a secret key. If someone gains access to a secret key to an account, they can withdraw all the coins it contains. If the secret key for an account is lost, any coins that have been sent to that account's address are permanently lost.","title":"What is a Wallet?"},{"location":"wallet/01-wallet-guide/#supported-wallets","text":"BOSAGORA supports web wallet and mobile app wallet.","title":"Supported Wallets"},{"location":"wallet/mobile/01-introduction/","text":"Introduction","title":"Introduction"},{"location":"wallet/mobile/01-introduction/#introduction","text":"","title":"Introduction"},{"location":"wallet/mobile/02-getting-started/","text":"Getting Started","title":"Getting Started"},{"location":"wallet/mobile/02-getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"wallet/mobile/03-how-to/","text":"How to","title":"How to"},{"location":"wallet/mobile/03-how-to/#how-to","text":"","title":"How to"},{"location":"wallet/web/01-introduction/","text":"Introduction Features The ability to register multiple accounts is provided. The ability to use multiple outgoing accounts for one transaction is provided. The freezing function required to create a validator is provided. The ability to manage contacts is provided. Monetary unit The monetary unit of coins used in BOSAGORA blockchain is BOA. BOA's decimal place is 7. Components of accounts The account consists of public key, secret key, and name. The public key is also used as the address of the account. The secret key is used when funds are transferred to another account. The secret key starts with S, its length is 56 and consists of alphabet and numbers. Example of a secret key) SDMCPWCYD4KAOOC3QNVSAWXYFBEORX7OADHARDSNJBKVIDO2M7GQ6DVX The public key starts with boa, its length is 63 and consists of lowercase alphabet and numbers. Example of a public key) boa1xraym009knpsxzguqz2mzjq78x0n06l9c2m3683346xd4vv3crq5qy7kx2y Balance of accounts The balance can be subdivided into the following. Total balance : This is the sum of all UTXOs held by the account. Spendable balance : This is the sum of UTXO that can be spent on the account. Frozen balance : The sum of the frozen UTXO. Locked balance : This is the sum of UTXO that cannot be used for a certain period. There are two types of locked balances. The first is that the frozen UTXO is unfrozen, and the newly created UTXO is locked until 2016 new blocks are created. The second is the amount of UTXO used for the pending transaction. The UTXO consumed in the transaction is locked until the block containing it is externalized. Add an account You can add multiple accounts. You can register a public key or a secret key when creating an account. When you attempt to withdraw funds from an account with only a public key registered, The web wallet presents a screen that allows you to enter the secret key. Also, this applies equally to the login screen. When you register a public key on the login screen, you can see the balance and transactions history. If you register a secret key, you can use all the functions. If you inquire only about the transactions history or balance without depositing, the risk of leakage of the secret key can be prevented because there is no need to register the secret key. Manage accounts When you close your browser or go to another site, all the secret keys registered in the wallet are removed. Therefore, you must record and keep the secret key of the account created in this wallet. If not, it should be noted that the loss of funds may occur. All the secret keys are removed when you reconnect, but the public key that was included in the secret key remains. Therefore, you can check your balance and transaction history without entering a separate key. However, since all accounts have only public keys, The web wallet presents you with a screen where you can enter a secret key in case of withdrawal of funds. You can complete the transfer of funds after entering the secret key you have recorded separately. If you haven't backed up your secret key, you won't be able to use the funds transferred to the account, so be extra careful. Transaction type There are three types of transaction types. It is Payment , Freezing , and Coinbase . Payment is the type of transaction used when funds are transferred. Freezing is a type of transaction used when the funds required to create a validator are frozen. Coinbase is a type of transaction used when node operation compensation and fee compensation are paid to node operators. Transaction transmission and completion When you create a transaction in the wallet and send it to the node, the node checks whether the received transaction is valid. Transactions that pass the validation check wait until they are stored in the blockchain. These transactions are called pending transactions. Nodes then preferentially select transactions with high transaction fee rates among pending transactions and store them in the blockchain. Transactions stored in the blockchain have been completed and cannot be changed. Transaction fee In order for a transaction to be successfully stored in the blockchain, a transaction fee must be paid. The wallet servers aggregate past transaction fees and suggest optimal fees according to the size of transaction data. The proposed fee options consist of three types: High , Medium , and Low . Transactions set at high fees are stored in the blockchain early, and transactions set at low fees are stored in the blockchain late. Transaction fee rate Transaction fees increase in proportion to the size of the transaction. At this time, the proportional constant is called the fee rate. Payload and payload fee BOSAGORA blockchain provides the ability to store the data you want to store in the blockchain. The name of this storage is the payload. In order for data to be stored here, a fee must be paid. The size of this fee increases exponentially with the size of the data, and the maximum size of the data is 1024Bytes. Transactions with payloads larger than the maximum size are rejected. Validator Nodes select transactions, go through an agreement process, make them into one same block, and store them in the blockchain. Nodes that can participate in the process of consensus on block creation are called validators. In order to become a validator, more than 40,000 BOA of funds must be frozen in the validator's account.","title":"Introduction"},{"location":"wallet/web/01-introduction/#introduction","text":"","title":"Introduction"},{"location":"wallet/web/01-introduction/#features","text":"The ability to register multiple accounts is provided. The ability to use multiple outgoing accounts for one transaction is provided. The freezing function required to create a validator is provided. The ability to manage contacts is provided.","title":"Features"},{"location":"wallet/web/01-introduction/#monetary-unit","text":"The monetary unit of coins used in BOSAGORA blockchain is BOA. BOA's decimal place is 7.","title":"Monetary unit"},{"location":"wallet/web/01-introduction/#components-of-accounts","text":"The account consists of public key, secret key, and name. The public key is also used as the address of the account. The secret key is used when funds are transferred to another account. The secret key starts with S, its length is 56 and consists of alphabet and numbers. Example of a secret key) SDMCPWCYD4KAOOC3QNVSAWXYFBEORX7OADHARDSNJBKVIDO2M7GQ6DVX The public key starts with boa, its length is 63 and consists of lowercase alphabet and numbers. Example of a public key) boa1xraym009knpsxzguqz2mzjq78x0n06l9c2m3683346xd4vv3crq5qy7kx2y","title":"Components of accounts"},{"location":"wallet/web/01-introduction/#balance-of-accounts","text":"The balance can be subdivided into the following. Total balance : This is the sum of all UTXOs held by the account. Spendable balance : This is the sum of UTXO that can be spent on the account. Frozen balance : The sum of the frozen UTXO. Locked balance : This is the sum of UTXO that cannot be used for a certain period. There are two types of locked balances. The first is that the frozen UTXO is unfrozen, and the newly created UTXO is locked until 2016 new blocks are created. The second is the amount of UTXO used for the pending transaction. The UTXO consumed in the transaction is locked until the block containing it is externalized.","title":"Balance of accounts"},{"location":"wallet/web/01-introduction/#add-an-account","text":"You can add multiple accounts. You can register a public key or a secret key when creating an account. When you attempt to withdraw funds from an account with only a public key registered, The web wallet presents a screen that allows you to enter the secret key. Also, this applies equally to the login screen. When you register a public key on the login screen, you can see the balance and transactions history. If you register a secret key, you can use all the functions. If you inquire only about the transactions history or balance without depositing, the risk of leakage of the secret key can be prevented because there is no need to register the secret key.","title":"Add an account"},{"location":"wallet/web/01-introduction/#manage-accounts","text":"When you close your browser or go to another site, all the secret keys registered in the wallet are removed. Therefore, you must record and keep the secret key of the account created in this wallet. If not, it should be noted that the loss of funds may occur. All the secret keys are removed when you reconnect, but the public key that was included in the secret key remains. Therefore, you can check your balance and transaction history without entering a separate key. However, since all accounts have only public keys, The web wallet presents you with a screen where you can enter a secret key in case of withdrawal of funds. You can complete the transfer of funds after entering the secret key you have recorded separately. If you haven't backed up your secret key, you won't be able to use the funds transferred to the account, so be extra careful.","title":"Manage accounts"},{"location":"wallet/web/01-introduction/#transaction-type","text":"There are three types of transaction types. It is Payment , Freezing , and Coinbase . Payment is the type of transaction used when funds are transferred. Freezing is a type of transaction used when the funds required to create a validator are frozen. Coinbase is a type of transaction used when node operation compensation and fee compensation are paid to node operators.","title":"Transaction type"},{"location":"wallet/web/01-introduction/#transaction-transmission-and-completion","text":"When you create a transaction in the wallet and send it to the node, the node checks whether the received transaction is valid. Transactions that pass the validation check wait until they are stored in the blockchain. These transactions are called pending transactions. Nodes then preferentially select transactions with high transaction fee rates among pending transactions and store them in the blockchain. Transactions stored in the blockchain have been completed and cannot be changed.","title":"Transaction transmission and completion"},{"location":"wallet/web/01-introduction/#transaction-fee","text":"In order for a transaction to be successfully stored in the blockchain, a transaction fee must be paid. The wallet servers aggregate past transaction fees and suggest optimal fees according to the size of transaction data. The proposed fee options consist of three types: High , Medium , and Low . Transactions set at high fees are stored in the blockchain early, and transactions set at low fees are stored in the blockchain late.","title":"Transaction fee"},{"location":"wallet/web/01-introduction/#transaction-fee-rate","text":"Transaction fees increase in proportion to the size of the transaction. At this time, the proportional constant is called the fee rate.","title":"Transaction fee rate"},{"location":"wallet/web/01-introduction/#payload-and-payload-fee","text":"BOSAGORA blockchain provides the ability to store the data you want to store in the blockchain. The name of this storage is the payload. In order for data to be stored here, a fee must be paid. The size of this fee increases exponentially with the size of the data, and the maximum size of the data is 1024Bytes. Transactions with payloads larger than the maximum size are rejected.","title":"Payload and payload fee"},{"location":"wallet/web/01-introduction/#validator","text":"Nodes select transactions, go through an agreement process, make them into one same block, and store them in the blockchain. Nodes that can participate in the process of consensus on block creation are called validators. In order to become a validator, more than 40,000 BOA of funds must be frozen in the validator's account.","title":"Validator"},{"location":"wallet/web/02-getting-started/","text":"Getting Started Login When there is no registered account, The web wallet shows the login screen. You can choose a language here. Then, press the button Create New Account to move to the next screen. You can change the language using the menu Setting in the wallet. You can start the wallet by entering a secret key or public key and the name of your account, and then pressing the button OK. If you don't have a secret key or a public key, you can generate a new key by pressing the button Create. The web wallet does not keep the secret key generated here. You must enter a secret key when logging on the web wallet again. If you haven't backed up your secret key, you won't be able to use the funds transferred to the account, so be extra careful. A detailed description of the account is provided in Manage accounts . Menu All screens have menus on the left. The menu includes Overview, Transactions history, Send BOA, Create Validator, Unfreezing, Store Data, Contact List, and Settings. Overview You can see the last 10 completed transactions and pending transactions of the selected account here. Transactions History You can see the past transactions of the selected account here. Send BOA You can transfer funds from here to another account. Create Validator At least 40,000 BOA must be frozen to create a validator node in BOASGORA's network. You can freeze the funds here. In this process, additional keypairs are created for node operation. This key pair is used to set up nodes. Unfreezing The ability to release frozen funds is provided to create a validator. Store Data You can store data in the blockchain here. Contact List The contact is the address you often use when you transfer. Contacts make it easy for users to select addresses when transferring. Therefore, you can easily distinguish transaction details by the contact name registered in the contact instead of the other party's address. Setting You can set network, language, time zone, etc. here. Status bar Account selection You can choose one of several registered accounts. You can also copy the public key of the account, delete the account, and add a new account. Network selection There are two networks in BOSAGORA. One is CoinNet, and the other is TestNet. CoinNet is a network in which actual coins with value are transmitted. TestNet is used to test, and the coins here do not have actual value. Balance The web wallet shows two types of balance. One is the balance of the selected account, and the other is the sum of all registered accounts. In addition, the balance can be subdivided into the following. Total balance : This is the sum of all UTXOs held by the account. Spendable balance: This is the sum of UTXO that can be spent on the account. Frozen balance : The sum of the frozen UTXO. Locked balance : This is the sum of UTXO that cannot be used for a certain period. There are two types of locked balances. The first is that the frozen UTXO is unfrozen, and the newly created UTXO is locked until 2016 new blocks are created. The second is the amount of UTXO used for the pending transaction. The UTXO consumed in the transaction is locked until the block containing it is externalized. Mode status The public key must be registered in your account, but the secret key may not be registered. The mode of the account where the secret key is registered is Sudo. The mode of the account where the secret key isn't registered is ReadOnly. The web wallet shows the number of Sudo, making it easy for you to figure out the number of secret keys registered on the web wallet. Overview This screen consists of two areas: Recent Transactions and Pending Transactions. Recent Transactions The web wallet only shows transactions in which the address of the selected account among the recent transactions stored in the blockchain is the same as either the sender's address, or the receiver's address. The fields consist of Transaction type, Time, Amount, and Peer. The top record is the most recently generated transaction. When one record is selected, detailed transaction information is provided. Transaction type are Inbound, Outbound, Freezing, and Payload. Inbound : Funds are added to the selected account. Outbound : Funds are withdrawn from the selected account. Freezing : Used to create a validator. Payload : Used to store data in the blockchain. Amount : The amount that was received, or spent. Peer : The address that sent (or received) the funds. Pending Transactions The web wallet only shows transactions in which the address of the selected account among the transactions waiting to be stored in the blockchain is the same as one of the sender's addresses. The fields consist of Submission time, Block delay, Amount, Target, Fee, and Action. Submission time : Time at which Stoa received the transaction. Block delay : Number of blocks externalized since then. Amount : Amount that the target will receive. Target : Receiver address, or name if known. Fee : Fee posted for this transaction. Transactions that have not yet been saved in the block may be canceled. The success of transaction cancellation cannot be guaranteed because it may be stored in a block during the cancellation process. Transactions History The web wallet only shows transactions in which the address of the selected account among the recent transactions stored in the blockchain is the same as either the sender's address, or the receiver's address. The fields consist of Transaction type, Time, Amount, and Peer. The top record is the most recently generated transaction. When one record is selected, detailed transaction information is provided. Transaction type are Inbound, Outbound, Freezing, and Payload. Inbound : Funds are added to the selected account. Outbound : Funds are withdrawn from the selected account. Freezing : Used to create a validator. Payload : Used to store data in the blockchain. Amount: The amount that was received, or spent. Peer: The address that sent (or received) the funds.","title":"Getting Started"},{"location":"wallet/web/02-getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"wallet/web/02-getting-started/#login","text":"When there is no registered account, The web wallet shows the login screen. You can choose a language here. Then, press the button Create New Account to move to the next screen. You can change the language using the menu Setting in the wallet. You can start the wallet by entering a secret key or public key and the name of your account, and then pressing the button OK. If you don't have a secret key or a public key, you can generate a new key by pressing the button Create. The web wallet does not keep the secret key generated here. You must enter a secret key when logging on the web wallet again. If you haven't backed up your secret key, you won't be able to use the funds transferred to the account, so be extra careful. A detailed description of the account is provided in Manage accounts .","title":"Login"},{"location":"wallet/web/02-getting-started/#menu","text":"All screens have menus on the left. The menu includes Overview, Transactions history, Send BOA, Create Validator, Unfreezing, Store Data, Contact List, and Settings. Overview You can see the last 10 completed transactions and pending transactions of the selected account here. Transactions History You can see the past transactions of the selected account here. Send BOA You can transfer funds from here to another account. Create Validator At least 40,000 BOA must be frozen to create a validator node in BOASGORA's network. You can freeze the funds here. In this process, additional keypairs are created for node operation. This key pair is used to set up nodes. Unfreezing The ability to release frozen funds is provided to create a validator. Store Data You can store data in the blockchain here. Contact List The contact is the address you often use when you transfer. Contacts make it easy for users to select addresses when transferring. Therefore, you can easily distinguish transaction details by the contact name registered in the contact instead of the other party's address. Setting You can set network, language, time zone, etc. here.","title":"Menu"},{"location":"wallet/web/02-getting-started/#status-bar","text":"Account selection You can choose one of several registered accounts. You can also copy the public key of the account, delete the account, and add a new account. Network selection There are two networks in BOSAGORA. One is CoinNet, and the other is TestNet. CoinNet is a network in which actual coins with value are transmitted. TestNet is used to test, and the coins here do not have actual value. Balance The web wallet shows two types of balance. One is the balance of the selected account, and the other is the sum of all registered accounts. In addition, the balance can be subdivided into the following. Total balance : This is the sum of all UTXOs held by the account. Spendable balance: This is the sum of UTXO that can be spent on the account. Frozen balance : The sum of the frozen UTXO. Locked balance : This is the sum of UTXO that cannot be used for a certain period. There are two types of locked balances. The first is that the frozen UTXO is unfrozen, and the newly created UTXO is locked until 2016 new blocks are created. The second is the amount of UTXO used for the pending transaction. The UTXO consumed in the transaction is locked until the block containing it is externalized. Mode status The public key must be registered in your account, but the secret key may not be registered. The mode of the account where the secret key is registered is Sudo. The mode of the account where the secret key isn't registered is ReadOnly. The web wallet shows the number of Sudo, making it easy for you to figure out the number of secret keys registered on the web wallet.","title":"Status bar"},{"location":"wallet/web/02-getting-started/#overview","text":"This screen consists of two areas: Recent Transactions and Pending Transactions. Recent Transactions The web wallet only shows transactions in which the address of the selected account among the recent transactions stored in the blockchain is the same as either the sender's address, or the receiver's address. The fields consist of Transaction type, Time, Amount, and Peer. The top record is the most recently generated transaction. When one record is selected, detailed transaction information is provided. Transaction type are Inbound, Outbound, Freezing, and Payload. Inbound : Funds are added to the selected account. Outbound : Funds are withdrawn from the selected account. Freezing : Used to create a validator. Payload : Used to store data in the blockchain. Amount : The amount that was received, or spent. Peer : The address that sent (or received) the funds. Pending Transactions The web wallet only shows transactions in which the address of the selected account among the transactions waiting to be stored in the blockchain is the same as one of the sender's addresses. The fields consist of Submission time, Block delay, Amount, Target, Fee, and Action. Submission time : Time at which Stoa received the transaction. Block delay : Number of blocks externalized since then. Amount : Amount that the target will receive. Target : Receiver address, or name if known. Fee : Fee posted for this transaction. Transactions that have not yet been saved in the block may be canceled. The success of transaction cancellation cannot be guaranteed because it may be stored in a block during the cancellation process.","title":"Overview"},{"location":"wallet/web/02-getting-started/#transactions-history","text":"The web wallet only shows transactions in which the address of the selected account among the recent transactions stored in the blockchain is the same as either the sender's address, or the receiver's address. The fields consist of Transaction type, Time, Amount, and Peer. The top record is the most recently generated transaction. When one record is selected, detailed transaction information is provided. Transaction type are Inbound, Outbound, Freezing, and Payload. Inbound : Funds are added to the selected account. Outbound : Funds are withdrawn from the selected account. Freezing : Used to create a validator. Payload : Used to store data in the blockchain. Amount: The amount that was received, or spent. Peer: The address that sent (or received) the funds.","title":"Transactions History"},{"location":"wallet/web/03-how-to/","text":"How to How to add an account? Click on the account at the top of the screen, and you will see a menu called \"Add New Account\". Click \"Add a new account\", and you will see the screen below. Enter a secret key or public key here. When creating a new secret key, click the button \"Create\". Copy the newly created secret key and public key. You can click and copy the icon to the right of each key, and you have to store the copied key in a separate storage, and click the check box below, and click the button \"OK\" to close this pop-up window. You enter the secret key you copied and the name of the account, and click the button OK. Wallet adds a new account and allows the added account to be selected. How to copy the public key? When you click the account at the top of the screen, a pop-up menu appears. There are two icons to the right of each account. The first icon is the ability to copy the public key each account has to the clipboard. How to delete an account? Click on the account at the top of the screen to see a pop-up menu. There are two icons to the right of each account. When you click the second icon, the selected account is deleted. How to send BOA? You can select the menu \"Send BOA\" to send the BOA to the desired address. This screen consists of three areas: Receivers, Fee, and Senders. Receivers This is where you enter the receiving address and amount. The receiving address can be selected from the contact list. Fee A detailed description of the fee is here . Senders The field consists of Address, Drawn, Remaining, Spendable Balance, Balance, and Action. You can fill the insufficient amount of transfer by adding several accounts they send. At this time, the account must be registered in the wallet first. Address : The address of the added account. Drawn : The amount that would be withdrawn on the added account. Remaining : The amount needed to fill the sending amount. Spendable Balance : The sum of UTXO that can be spent on the added account. Balance : The sum of all UTXOs held by the account. If the Remaining is zero after you add one account, you no longer need to add an account. However, if the Remaining is greater than 0, a new account must be added. If added account's Remaining is zero, it means that the sum of the spendable balances of all accounts is greater than or equal to the transfer amount. In this case, the button Next is activated. When you press the button Next to proceed to the next step, The wallet provides a window for entering a secret key for an account with only a public key registered among the added accounts. Transaction Overview When a transaction is successfully created, it shows the details of the transaction. You must finally check the amount and address. Send Transaction When you click the button OK, the transaction is sent to the node. If normally received by the node, you can check the pending transactions on the Overview . Also, if the transaction has already been stored in the blockchain, you can check it in the Transactions History . How to create validator? You can select the menu \"Create Validator\" to create the validator's account. This screen consists of Freezing Amount, Validator Address, Fee, and Senders. Freezing Amount To become a validator, you need to have more than 40,000 BOA of frozen funds. The freezing amount is 40,000 BOA when the staking unit is zero, and each time the staking unit increases by 1, it increases by 10,000 BOA. Validator Address The validator's secret key is newly created and used. At this time, the newly created validator's secret key is registered directly to the account. The user must record and keep the secret key of this new validator separately. Otherwise, the funds transferred to the new account will not be available. Fee A detailed description of the fee is here . Senders The field consists of Address, Drawn, Remaining, Spendable Balance, Balance, and Action. You can fill the insufficient amount of transfer by adding several accounts they send. At this time, the account must be registered in the wallet first. Address : The address of the added account. Drawn : The amount that would be withdrawn on the added account. Remaining : The amount needed to fill the sending amount. Spendable Balance : The sum of UTXO that can be spent on the added account. Balance : The sum of all UTXOs held by the account. If the Remaining is zero after you add one account, you no longer need to add an account. However, if the Remaining is greater than 0, a new account must be added. If added account's Remaining is zero, it means that the sum of the spendable balances of all accounts is greater than or equal to the transfer amount. In this case, the button Next is activated. When you press the button Next to proceed to the next step, The wallet provides a window for entering a secret key for an account with only a public key registered among the added accounts. Transaction Overview When a transaction is successfully created, it shows the details of the transaction. You must finally check the amount and address. Send Transaction When you click the button OK, the transaction is sent to the node. If normally received by the node, you can check the pending transactions on the Overview . Also, if the transaction has already been stored in the blockchain, you can check it in the Transactions History . How to unfreezing? You can select the menu \"Unfreezing\" to release the frozen funds. This screen consists of two areas Selected UTXO and Fee. Unfreezing UTXO Shows the frozen UTXO currently in the selected account. You can select the left check box of the item you want to unfreeze. Fee A detailed description of the fee is here . Transaction Overview When a transaction is successfully created, it shows the details of the transaction. You must finally check the amount and address. Send Transaction When you click the button OK, the transaction is sent to the node. If normally received by the node, you can check the pending transactions on the Overview . Also, if the transaction has already been stored in the blockchain, you can check it in the Transactions History . How to store data in blockchain? You can select the menu \"Store Data\" to store data in the blockchain. This screen consists of three areas: Payload, Fee, and Senders. Payload Data to be stored in the blockchain. Text encoded with Base64 must be entered. Fee A detailed description of the fee is here . Senders The field consists of Address, Drawn, Remaining, Spendable Balance, Balance, and Action. You can fill the insufficient amount of transfer by adding several accounts they send. At this time, the account must be registered in the wallet first. Address : The address of the added account. Drawn : The amount that would be withdrawn on the added account. Remaining : The amount needed to fill the sending amount. Spendable Balance : The sum of UTXO that can be spent on the added account. Balance : The sum of all UTXOs held by the account. If the Remaining is zero after you add one account, you no longer need to add an account. However, if the Remaining is greater than 0, a new account must be added. If added account's Remaining is zero, it means that the sum of the spendable balances of all accounts is greater than or equal to the transfer amount. In this case, the button Next is activated. When you press the button Next to proceed to the next step, The wallet provides a window for entering a secret key for an account with only a public key registered among the added accounts. Transaction Overview When a transaction is successfully created, it shows the details of the transaction. You must finally check the amount and address. Send Transaction When you click the button OK, the transaction is sent to the node. If normally received by the node, you can check the pending transactions on the Overview . Also, if the transaction has already been stored in the blockchain, you can check it in the Transactions History . How to use contact? You can save the address of the other party. The user can select the menu \"Contact List\". The contact information consists of address and name. It makes it easy and safe to transfer funds from your account to an address registered in your contact number. Wallet also displays the transaction history as a name on behalf of the address registered in the contact. Therefore, users can easily grasp the contents of the transaction. Add Contact When the button \"Add Contact\" on the top right is clicked, the input window pops up. You can add by entering their address and contact name here. Edit Contact You can change the contact's name by clicking the icon Edit to the right of each contact's item. Delete Contact You can delete the contact by clicking the icon Delete to the right of each contact's item. How to set the wallet? Language You can choose between English, Korean, and Chinese. Endpoints You can check and change the endpoints of CoinNet and TestNet. Reset Wallet State All saved accounts and contacts will be deleted. Timezone You can choose between Local Time and UTC. Dark Mode You can change the background color of the screen. Dark Mode and Light Mode are provided.","title":"How to"},{"location":"wallet/web/03-how-to/#how-to","text":"","title":"How to"},{"location":"wallet/web/03-how-to/#how-to-add-an-account","text":"Click on the account at the top of the screen, and you will see a menu called \"Add New Account\". Click \"Add a new account\", and you will see the screen below. Enter a secret key or public key here. When creating a new secret key, click the button \"Create\". Copy the newly created secret key and public key. You can click and copy the icon to the right of each key, and you have to store the copied key in a separate storage, and click the check box below, and click the button \"OK\" to close this pop-up window. You enter the secret key you copied and the name of the account, and click the button OK. Wallet adds a new account and allows the added account to be selected.","title":"How to add an account?"},{"location":"wallet/web/03-how-to/#how-to-copy-the-public-key","text":"When you click the account at the top of the screen, a pop-up menu appears. There are two icons to the right of each account. The first icon is the ability to copy the public key each account has to the clipboard.","title":"How to copy the public key?"},{"location":"wallet/web/03-how-to/#how-to-delete-an-account","text":"Click on the account at the top of the screen to see a pop-up menu. There are two icons to the right of each account. When you click the second icon, the selected account is deleted.","title":"How to delete an account?"},{"location":"wallet/web/03-how-to/#how-to-send-boa","text":"You can select the menu \"Send BOA\" to send the BOA to the desired address. This screen consists of three areas: Receivers, Fee, and Senders. Receivers This is where you enter the receiving address and amount. The receiving address can be selected from the contact list. Fee A detailed description of the fee is here . Senders The field consists of Address, Drawn, Remaining, Spendable Balance, Balance, and Action. You can fill the insufficient amount of transfer by adding several accounts they send. At this time, the account must be registered in the wallet first. Address : The address of the added account. Drawn : The amount that would be withdrawn on the added account. Remaining : The amount needed to fill the sending amount. Spendable Balance : The sum of UTXO that can be spent on the added account. Balance : The sum of all UTXOs held by the account. If the Remaining is zero after you add one account, you no longer need to add an account. However, if the Remaining is greater than 0, a new account must be added. If added account's Remaining is zero, it means that the sum of the spendable balances of all accounts is greater than or equal to the transfer amount. In this case, the button Next is activated. When you press the button Next to proceed to the next step, The wallet provides a window for entering a secret key for an account with only a public key registered among the added accounts. Transaction Overview When a transaction is successfully created, it shows the details of the transaction. You must finally check the amount and address. Send Transaction When you click the button OK, the transaction is sent to the node. If normally received by the node, you can check the pending transactions on the Overview . Also, if the transaction has already been stored in the blockchain, you can check it in the Transactions History .","title":"How to send BOA?"},{"location":"wallet/web/03-how-to/#how-to-create-validator","text":"You can select the menu \"Create Validator\" to create the validator's account. This screen consists of Freezing Amount, Validator Address, Fee, and Senders. Freezing Amount To become a validator, you need to have more than 40,000 BOA of frozen funds. The freezing amount is 40,000 BOA when the staking unit is zero, and each time the staking unit increases by 1, it increases by 10,000 BOA. Validator Address The validator's secret key is newly created and used. At this time, the newly created validator's secret key is registered directly to the account. The user must record and keep the secret key of this new validator separately. Otherwise, the funds transferred to the new account will not be available. Fee A detailed description of the fee is here . Senders The field consists of Address, Drawn, Remaining, Spendable Balance, Balance, and Action. You can fill the insufficient amount of transfer by adding several accounts they send. At this time, the account must be registered in the wallet first. Address : The address of the added account. Drawn : The amount that would be withdrawn on the added account. Remaining : The amount needed to fill the sending amount. Spendable Balance : The sum of UTXO that can be spent on the added account. Balance : The sum of all UTXOs held by the account. If the Remaining is zero after you add one account, you no longer need to add an account. However, if the Remaining is greater than 0, a new account must be added. If added account's Remaining is zero, it means that the sum of the spendable balances of all accounts is greater than or equal to the transfer amount. In this case, the button Next is activated. When you press the button Next to proceed to the next step, The wallet provides a window for entering a secret key for an account with only a public key registered among the added accounts. Transaction Overview When a transaction is successfully created, it shows the details of the transaction. You must finally check the amount and address. Send Transaction When you click the button OK, the transaction is sent to the node. If normally received by the node, you can check the pending transactions on the Overview . Also, if the transaction has already been stored in the blockchain, you can check it in the Transactions History .","title":"How to create validator?"},{"location":"wallet/web/03-how-to/#how-to-unfreezing","text":"You can select the menu \"Unfreezing\" to release the frozen funds. This screen consists of two areas Selected UTXO and Fee. Unfreezing UTXO Shows the frozen UTXO currently in the selected account. You can select the left check box of the item you want to unfreeze. Fee A detailed description of the fee is here . Transaction Overview When a transaction is successfully created, it shows the details of the transaction. You must finally check the amount and address. Send Transaction When you click the button OK, the transaction is sent to the node. If normally received by the node, you can check the pending transactions on the Overview . Also, if the transaction has already been stored in the blockchain, you can check it in the Transactions History .","title":"How to unfreezing?"},{"location":"wallet/web/03-how-to/#how-to-store-data-in-blockchain","text":"You can select the menu \"Store Data\" to store data in the blockchain. This screen consists of three areas: Payload, Fee, and Senders. Payload Data to be stored in the blockchain. Text encoded with Base64 must be entered. Fee A detailed description of the fee is here . Senders The field consists of Address, Drawn, Remaining, Spendable Balance, Balance, and Action. You can fill the insufficient amount of transfer by adding several accounts they send. At this time, the account must be registered in the wallet first. Address : The address of the added account. Drawn : The amount that would be withdrawn on the added account. Remaining : The amount needed to fill the sending amount. Spendable Balance : The sum of UTXO that can be spent on the added account. Balance : The sum of all UTXOs held by the account. If the Remaining is zero after you add one account, you no longer need to add an account. However, if the Remaining is greater than 0, a new account must be added. If added account's Remaining is zero, it means that the sum of the spendable balances of all accounts is greater than or equal to the transfer amount. In this case, the button Next is activated. When you press the button Next to proceed to the next step, The wallet provides a window for entering a secret key for an account with only a public key registered among the added accounts. Transaction Overview When a transaction is successfully created, it shows the details of the transaction. You must finally check the amount and address. Send Transaction When you click the button OK, the transaction is sent to the node. If normally received by the node, you can check the pending transactions on the Overview . Also, if the transaction has already been stored in the blockchain, you can check it in the Transactions History .","title":"How to store data in blockchain?"},{"location":"wallet/web/03-how-to/#how-to-use-contact","text":"You can save the address of the other party. The user can select the menu \"Contact List\". The contact information consists of address and name. It makes it easy and safe to transfer funds from your account to an address registered in your contact number. Wallet also displays the transaction history as a name on behalf of the address registered in the contact. Therefore, users can easily grasp the contents of the transaction. Add Contact When the button \"Add Contact\" on the top right is clicked, the input window pops up. You can add by entering their address and contact name here. Edit Contact You can change the contact's name by clicking the icon Edit to the right of each contact's item. Delete Contact You can delete the contact by clicking the icon Delete to the right of each contact's item.","title":"How to use contact?"},{"location":"wallet/web/03-how-to/#how-to-set-the-wallet","text":"Language You can choose between English, Korean, and Chinese. Endpoints You can check and change the endpoints of CoinNet and TestNet. Reset Wallet State All saved accounts and contacts will be deleted. Timezone You can choose between Local Time and UTC. Dark Mode You can change the background color of the screen. Dark Mode and Light Mode are provided.","title":"How to set the wallet?"}]}